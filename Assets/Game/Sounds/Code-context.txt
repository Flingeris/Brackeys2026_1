--------------------
File: /Code/Cards/CardInstance.cs
--------------------

using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UIElements;

public class CardState
{
    public CardModel model;
}

public class CardInstance : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    public CardState state;
    [Header("References")] public DraggableCard Draggable;
    public Hand Hand => G.Hand;

    [SerializeField] private TMP_Text cardNameText;
    [SerializeField] private TMP_Text cardDescText;
    [SerializeField] private TMP_Text cardClassText;
    [SerializeField] private TMP_Text turnIndexText;

    [SerializeField] private SpriteRenderer cardSprite;


    public void SetState(CardState newState)
    {
        this.state = newState;
        UpdateVisuals();
    }

    public void SetModel(CardModel model)
    {
        if (model == null) return;

        var newState = new CardState()
        {
            model = model
        };

        SetState(newState);
    }

    private void UpdateVisuals()
    {
        UpdateClassText();
        UpdateSprite();
        UpdateName();
        UpdateDescription();
    }

    private void UpdateName()
    {
        cardNameText.text = state.model.name;
    }

    private void UpdateDescription()
    {
        cardDescText.text = state.model.Description;
    }


    private void UpdateClassText()
    {
        cardClassText.text = state.model.ClassType.ToString()[0].ToString();
    }


    private void UpdateSprite()
    {
        cardSprite.sprite = state.model.Sprite;
    }


    public IEnumerator OnCardPlayed()
    {
        var inters = state.model.OnPlayedCardInteractions;
        foreach (var i in inters)
        {
            yield return i.OnPlay(state);
        }
    }


    public IEnumerator OnTurnEnd()
    {
        var startPos = transform.position;
        var NewPos = startPos;
        NewPos.y += 0.8f;
        yield return transform.DOMove(NewPos, 0.2f).WaitForCompletion();

        var inters = state.model.OnTurnEndInteractions;
        foreach (var i in inters)
        {
            yield return i.OnEndTurn(state);
        }

        transform.DOShakePosition(0.5f, 0.2f, 40);


        yield return new WaitForSeconds(0.5f);
        yield return transform.DOMove(startPos, 0.2f).WaitForCompletion();
    }


    public void OnPointerEnter(PointerEventData eventData)
    {
        if (G.main.IsChoosingTarget) return;
        List<ICardInteraction> inters = new List<ICardInteraction>();
        inters.AddRange(state.model.OnPlayedCardInteractions);
        inters.AddRange(state.model.OnTurnEndInteractions);
        bool isTarget = false;
        foreach (var i in inters)
        {
            if (i is ChooseTargetInteractionBase targetInteraction)
            {
                isTarget = true;
            }
        }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (G.main.IsChoosingTarget) return;
    }
}

--------------------
File: /Code/Cards/CardModel.cs
--------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

public enum ClassType
{
    None = 0,
    Heal = 1,
    Tank = 2,
    Damage = 3,
}

public enum CardType
{
    None = 0,
    Start = 1,
    Mid = 2,
    End = 3
}


public abstract class CardModel : ContentDef, ITooltipInfo
{
    [Header("Card info")]
    [field: SerializeField]
    public string ItemName { get; protected set; }

    public string Description => GetDescription();

    [Header("Card visuals")] public Sprite Sprite;
    public CardInstance Prefab => "prefabs/Card".Load<CardInstance>();

    [Header("Stats")] public abstract ClassType ClassType { get; }

    public CardType CardType;
    [SerializeReference, SubclassSelector] public List<IOnCardPlayed> OnPlayedCardInteractions;


    [Space(10f)] [SerializeReference, SubclassSelector]
    public List<IOnCardEndTurn> OnTurnEndInteractions;

    public string GetDescription()
    {
        if (OnTurnEndInteractions == null || OnTurnEndInteractions.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        for (int i = 0; i < OnTurnEndInteractions.Count; i++)
        {
            var interaction = OnTurnEndInteractions[i];
            if (interaction == null)
                continue;

            if (sb.Length > 0)
                sb.Append('\n');

            sb.Append(interaction.desc);
        }

        return sb.ToString();
    }
}


[Serializable]
public class AddStatusToTargetInteraction : IOnCardEndTurn
{
    [SerializeReference, SubclassSelector] public IStatusEffectInteraction statusToAdd;
    public int stacksToAdd;

    public string desc => "Apply " + stacksToAdd + " Stacks of " + statusToAdd.GetType() + " to target";

    public IEnumerator OnEndTurn(CardState state)
    {
        var target = G.main.Target;
        if (target == null) yield break;
        target.AddStatus(statusToAdd, stacksToAdd);
    }
}

[Serializable]
public class AddStatusToClassInteractions : IOnCardEndTurn
{
    [SerializeReference, SubclassSelector] public IStatusEffectInteraction statusToAdd;
    public ClassType member;
    public int stacksToAdd;

    public string desc => "Apply " + stacksToAdd + " Stacks of " + statusToAdd.GetType() + " to " + member;

    public IEnumerator OnEndTurn(CardState state)
    {
        var target = G.party.GetMemberByClass(member);
        if (target == null) yield break;
        target.AddStatus(statusToAdd, stacksToAdd);
    }
}

--------------------
File: /Code/Cards/ChooseTargetInteractionBase.cs
--------------------

using System.Collections;

public abstract class ChooseTargetInteractionBase
{
    public TargetSide TargetSide;
    public int[] possiblePositions;

    protected virtual IEnumerator OnTargetChoose()
    {
        yield return G.main.ChooseTarget(TargetSide, possiblePositions);
    }
}

--------------------
File: /Code/Cards/DamageCard.cs
--------------------

using System;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "DamageCard", menuName = "Cards/DamageCard", order = 3)]
public class DamageCard : CardModel
{
    public override ClassType ClassType => ClassType.Damage;
}


[Serializable]
public class RandomTargetDamageInteraction : IOnCardEndTurn
{
    public string desc => "Deals " + DmgAmount + " dmg to random target";
    public int DmgAmount;

    public IEnumerator OnEndTurn(CardState state)
    {
        var enemy = G.enemies.GetRandomMember();
        if (enemy == null) yield break;
        enemy.TakeDamage(DmgAmount);
        yield return null;
    }
}

[Serializable]
public class DealDamageToTarget : IOnCardEndTurn
{
    public string desc => "Deals " + DmgAmount + " dmg to chosen target";
    public int DmgAmount;

    public IEnumerator OnEndTurn(CardState state)
    {
        var target = G.main.Target;
        if (target == null) yield break;

        target.TakeDamage(DmgAmount);
        yield return null;
    }
}

[Serializable]
public class DealDamageToAllInteraction : IOnCardEndTurn
{
    public string desc => "Deals " + DmgAmount + " dmg to all enemies";
    public int DmgAmount;

    public IEnumerator OnEndTurn(CardState state)
    {
        G.enemies.DamageAll(DmgAmount);
        yield return null;
    }
}

[Serializable]
public class DealDamageForEachClassCard : IOnCardEndTurn
{
    public int AddDmg;
    public ClassType classCardsType = ClassType.Damage;

    public string desc =>
        "Deal " + AddDmg + " dmg to target enemy for each` " + classCardsType + " card on field";

    public IEnumerator OnEndTurn(CardState state)
    {
        var count = G.main.field.CountCardsWithClass(classCardsType);
        var target = G.main.Target;
        if (target == null) yield break;
        target.TakeDamage(AddDmg);
    }
}


[Serializable]
public class AddDamageForStatus : IOnCardEndTurn
{
    public int AddDmg;
    public StatusEffectType status;

    public string desc =>
        "Deal " + AddDmg + " dmg to target enemy for each` " + status + " stack on it";

    public IEnumerator OnEndTurn(CardState state)
    {
        var target = G.main.Target;
        if (target == null) yield break;

        var stack = target.StatusTypeStacks(status);

        target.TakeDamage(stack * AddDmg);
    }
}

--------------------
File: /Code/Cards/DraggableCard.cs
--------------------

using System.Collections;
using DG.Tweening;
using UnityEngine;
using UnityEngine.EventSystems;

public class DraggableCard
    : DraggableWContainer<DraggableCard, IDraggableContainer<DraggableCard>>
{
    public CardInstance instance;

    [Header("Drag physics")] [SerializeField]
    private float dragMaxSpeed = 20f;

    [SerializeField] private float dragAccelLerp = 25f;
    [SerializeField] private float dragTiltAmount = 1f;
    [SerializeField] private float dragTiltReturnSpeed = 10f;
    [SerializeField] float spring = 60f;
    [SerializeField] float damping = 10f; // сопротивление, чтобы не разносило 

    [Header("Visual")] [SerializeField] private Transform visual;

    private Vector3 dragTargetPos;
    private Vector3 dragVelocity;
    private float currentTilt;
    private Quaternion baseVisualLocalRot;
    private bool wasInContainerOnDragStart;
    private IDraggableContainer<DraggableCard> dragSourceContainer;


    private void Awake()
    {
        if (visual == null)
        {
            var t = transform.Find("Visual");
            if (t != null) visual = t;
        }

        if (visual != null)
            baseVisualLocalRot = visual.localRotation;
    }

    public override void OnBeginDrag(PointerEventData eventData)
    {
        base.OnBeginDrag(eventData);
        
        float pitch = Random.Range(0.96f, 1.04f);
        G.audioSystem.PlayPitched(SoundId.SFX_CardGrab, pitch);
        
        if (visual != null)
            visual.DOKill();
        
        dragSourceContainer = CurrContainer;
        
        if (CurrContainer != null)
        {
            CurrContainer.TryRemove(this);
            SetContainer(null);
        }
        
        var cursorWorldPos = mainCamera.ScreenToWorldPoint(eventData.position);
        cursorWorldPos.z = transform.position.z;
        dragTargetPos = cursorWorldPos + offset;

        dragVelocity = Vector3.zero;
        transform.localRotation = Quaternion.identity;
    }

    protected override void UpdatePosToCursor()
    {
        var cursorWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
        cursorWorldPos.z = transform.position.z;
        dragTargetPos = cursorWorldPos + offset;
    }

    private void Update()
    {
        if (!IsDragging) return;

        UpdateDragPhysics();
    }


    private void UpdateDragPhysics()
    {
        Vector3 toTarget = dragTargetPos - transform.position;

        // F = kx - bv
        Vector3 accel = toTarget * spring - dragVelocity * damping;
        dragVelocity += accel * Time.deltaTime;

        transform.position += dragVelocity * Time.deltaTime;

        float targetTilt = Mathf.Clamp(-dragVelocity.x * dragTiltAmount, -80f, 80f);
        currentTilt = Mathf.Lerp(currentTilt, targetTilt, dragTiltReturnSpeed * Time.deltaTime);

        if (visual != null)
            visual.localRotation = baseVisualLocalRot * Quaternion.Euler(0f, 0f, currentTilt);
    }

    public override void OnEndDrag(PointerEventData eventData)
    {
        base.OnEndDrag(eventData);
        dragVelocity = Vector3.zero;
        // currentTilt = 0f;

        // if (visual != null)
        // visual.localRotation = baseVisualLocalRot;
    }

    protected override IEnumerator PutInContainerSequence(IDraggableContainer<DraggableCard> targetCont)
{
    var sourceCont = dragSourceContainer;
    bool fromSlot = sourceCont != null;
    
    if (targetCont == null)
    {
        if (fromSlot)
        {
            SetContainer(null);
            SetOwner(G.Hand);
        }
        else
        {
            ReturnToOrigin();
        }

        PutInContCoroutine = null;
        dragSourceContainer = null;
        yield break;
    }
    
    if (fromSlot && targetCont == sourceCont)
    {
        if (!targetCont.TryAccept(this, out _))
        {
            SetOwner(G.Hand);
        }
        else
        {
            SetContainer(targetCont);
        }

        PutInContCoroutine = null;
        dragSourceContainer = null;
        yield break;
    }
    
    if (!targetCont.TryAccept(this, out var oldCard))
    {
        if (fromSlot)
        {
            SetContainer(null);
            SetOwner(G.Hand);
        }
        else
        {
            ReturnToOrigin();
        }

        PutInContCoroutine = null;
        dragSourceContainer = null;
        yield break;
    }
    
    SetContainer(targetCont);
    
    if (oldCard != null && oldCard != this)
    {
        if (fromSlot && sourceCont != null && sourceCont.CanAccept(oldCard))
        {
            sourceCont.TryAccept(oldCard, out _);
            oldCard.SetContainer(sourceCont);
        }
        else
        {
            oldCard.SetContainer(null);
            oldCard.SetOwner(G.Hand);
        }

        float pitch = 1f;
        G.audioSystem.PlayPitched(SoundId.SFX_CardSwap, pitch);
    }

    PutInContCoroutine = null;
    dragSourceContainer = null;
}

}

--------------------
File: /Code/Cards/HealerCard.cs
--------------------

using System;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "HealerCard", menuName = "Cards/HealerCard", order = 1)]
public class HealerCard : CardModel
{
    public override ClassType ClassType => ClassType.Heal;
}


[Serializable]
public class HealWeakestInteraction : IOnCardEndTurn
{
    public int HealAmount;
    public float AdditionalHealCondition;
    public int AdditionalHealAmount;

    public string desc => "+" + HealAmount + " hp to lowest ally. If ally hp is <=" + AdditionalHealCondition +
                          " +" + AdditionalHealAmount + "hp instead";

    public IEnumerator OnEndTurn(CardState state)
    {
        var lowest = G.party.GetLowestMember();
        if (lowest == null) yield break;
        if (lowest.CurrHP <= AdditionalHealCondition)
        {
            lowest.Heal(AdditionalHealAmount);
        }
        else
        {
            lowest.Heal(HealAmount);
        }

        yield return null;
    }
}

[Serializable]
public class HealAllForEachClassCardInteraction : IOnCardEndTurn
{
    public int AdditionalHealAmount;
    public ClassType classCardsType = ClassType.Heal;

    public string desc =>
        "+" + AdditionalHealAmount + " hp to all allies for each + " + classCardsType + " card on field";

    public IEnumerator OnEndTurn(CardState state)
    {
        var addHeal = 0;
        foreach (var card in G.main.field.PlayedCards)
        {
            if (card == null) continue;
            if (card.state.model.ClassType == classCardsType)
            {
                addHeal++;
            }
        }

        G.party.HealAll(addHeal * AdditionalHealAmount);
        yield break;
    }
}


[Serializable]
public class TargetHealInteraction : IOnCardEndTurn
{
    public int HealAmount;

    public string desc => "+" + HealAmount + " hp to target";

    public IEnumerator OnEndTurn(CardState card)
    {
        var target = G.main.Target;
        if (target == null) yield break;
        target.Heal(HealAmount);
    }
}


[Serializable]
public class HealAllInteraction : IOnCardEndTurn
{
    public int HealAmount;
    public string desc => "+" + HealAmount + " hp to all allies";


    public IEnumerator OnEndTurn(CardState state)
    {
        G.party.HealAll(HealAmount);
        yield break;
    }
}

[Serializable]
public class TargetRandomHealInteraction : IOnCardEndTurn
{
    public int MinHealAmount;
    public int MaxHealAmount;
    public string desc => "+ " + MinHealAmount + "-" + MaxHealAmount + " hp to target ally";


    public IEnumerator OnEndTurn(CardState state)
    {
        var target = G.main.Target;
        if (target == null) yield break;
        var heal = UnityEngine.Random.Range(MinHealAmount, MaxHealAmount);
        target.Heal(heal);
    }
}

--------------------
File: /Code/Cards/IOnCardEndTurn.cs
--------------------

using System;
using System.Collections;

public interface IOnCardEndTurn : ICardInteraction
{
    public string desc { get; }
    public IEnumerator OnEndTurn(CardState card);
}


[Serializable]
public class ChooseTargetOnTurnEndInteraction : ChooseTargetInteractionBase, IOnCardEndTurn
{
    public string desc => string.Empty;

    public IEnumerator OnEndTurn(CardState state)
    {
        yield return OnTargetChoose();
    }
}

--------------------
File: /Code/Cards/IOnCardPlayed.cs
--------------------

using System;
using System.Collections;

public interface ICardInteraction
{
}


public interface IOnCardPlayed : ICardInteraction
{
    public string desc { get; }
    public IEnumerator OnPlay(CardState card);
}


[Serializable]
public class ChooseTargetInteraction : ChooseTargetInteractionBase, IOnCardPlayed
{
    public string desc => string.Empty;

    public IEnumerator OnPlay(CardState state)
    {
        yield return G.main.ChooseTarget(TargetSide, possiblePositions);
    }
}

--------------------
File: /Code/Cards/TankCard.cs
--------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "TankCard", menuName = "Cards/TankCard", order = 2)]
public class TankCard : CardModel
{
    public override ClassType ClassType => ClassType.Tank;
}


[Serializable]
public class AddShieldToClassInteraction : IOnCardEndTurn
{
    public string desc => "+" + ShieldAmount + " shield to " + ClassType;
    public int ShieldAmount;
    public ClassType ClassType = ClassType.Tank;

    public IEnumerator OnEndTurn(CardState state)
    {
        var memberByClass = G.party.GetMemberByClass(ClassType);
        if (memberByClass == null) yield break;
        memberByClass.AddShield(ShieldAmount);
    }
}

[Serializable]
public class AddTauntChargesInteraction : IOnCardEndTurn
{
    public string desc => "+" + ShieldAmount + " shield to " + ClassType;
    public int ShieldAmount;
    public ClassType ClassType = ClassType.Tank;

    public IEnumerator OnEndTurn(CardState state)
    {
        var memberByClass = G.party.GetMemberByClass(ClassType);
        if (memberByClass == null) yield break;
    }
}


[Serializable]
public class ShieldAllInteraction : IOnCardEndTurn
{
    public string desc => "+" + ShieldAmount + " shield to all allies";
    public int ShieldAmount;

    public IEnumerator OnEndTurn(CardState state)
    {
        G.party.ShieldAll(ShieldAmount);
        yield break;
    }
}

[Serializable]
public class ShieldAllForEveryClassCard : IOnCardEndTurn 
{
    public int AdditionalShieldAmount;
    public ClassType classCardsType = ClassType.Tank;

    public string desc =>
        "+" + AdditionalShieldAmount + " shield to all allies for each " + classCardsType + " card on field";

    public IEnumerator OnEndTurn(CardState state)
    {
        var counter = G.main.field.CountCardsWithClass(classCardsType);

        G.party.ShieldAll(counter * AdditionalShieldAmount);
        yield break;
    }
}

--------------------
File: /Code/Characters/CombatGroup.cs
--------------------

using System;
using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;
using UnityEngine;


public enum TargetSide
{
    Any = 0,
    Allies = 1,
    Enemies = 2,
}

public abstract class CombatGroup : MonoBehaviour
{
    protected abstract TargetSide Side { get; }
    protected ICombatEntity[] partyMembers;

    [SerializeField] protected Transform[] membersPos;
    public int maxMembersCount = 3;

    protected virtual void Awake()
    {
        partyMembers = new ICombatEntity[maxMembersCount];
    }

    protected void AddMember(ICombatEntity member, int index)
    {
        partyMembers[index] = member;
    }

    public void Clear()
    {
        for (int i = 0; i < partyMembers.Length; i++)
        {
            if (partyMembers[i] is MonoBehaviour mb && mb != null)
            {
                Destroy(mb.gameObject);
            }

            partyMembers[i] = null;
        }
    }

    public ICombatEntity GetMember(int index)
    {
        return partyMembers[index];
    }


    public bool CheckIsAlive(int target)
    {
        return partyMembers[target] != null && !partyMembers[target].IsDead;
    }

    public List<ICombatEntity> GetMembers(int[] positions)
    {
        if (positions == null || positions.Length == 0)
        {
            return GetAliveMembers();
        }

        return positions.Select(i => partyMembers[i]).ToList();
    }

    private int GetTauntRedirectIndex(int originalIndex)
    {
        var alive = GetAliveMembers();
        if (alive == null || alive.Count == 0)
            return originalIndex;

        var tauntIndices = new List<int>();


        for (int i = 0; i < partyMembers.Length; i++)
        {
            var m = GetMember(i);
            if (m == null || m.IsDead) continue;

            if (m.StatusTypeStacks(StatusEffectType.Taunt) > 0)
                tauntIndices.Add(i);
        }

        if (tauntIndices.Count == 0 || tauntIndices.Contains(originalIndex))
            return originalIndex;

        var index = tauntIndices.GetRandomElement();
        GetMember(index).statusEffects.Where(s => s.Type == StatusEffectType.Taunt).ToList().FirstOrDefault()?.Tick();
        return index;
    }


    public void TargetAll()
    {
        foreach (var member in partyMembers)
            member.SetTarget(true);
    }

    public void UntargetAll()
    {
        foreach (var member in partyMembers)
        {
            member.SetTarget(false);
        }
    }


    public void DealDamage(int target, int damage)
    {
        var finalTarget = GetTauntRedirectIndex(target);
        var combatEntity = GetMember(finalTarget);
        if (combatEntity == null || combatEntity.IsDead) return;
        combatEntity.TakeDamage(damage);
    }

    public void DamageAll(int amount)
    {
        foreach (var member in partyMembers)
        {
            if (!member.IsDead)
            {
                member.TakeDamage(amount);
            }
        }
    }

    public void Heal(int target, int amount)
    {
        var member = partyMembers[target];
        if (member == null || member.IsDead) return;
        member.Heal(amount);
    }

    public void HealAll(int amount)
    {
        foreach (var member in partyMembers)
        {
            if (!member.IsDead)
                member.Heal(amount);
        }
    }


    public void AddShield(int target, int amount)
    {
        var member = partyMembers[target];
        if (member == null || member.IsDead) return;
        member.AddShield(amount);
    }

    public void ShieldAll(int amount)
    {
        foreach (var member in partyMembers)
        {
            if (!member.IsDead)
                member.AddShield(amount);
        }
    }


    public virtual void CheckMemberDeath(ICombatEntity member)
    {
        if (AllMembersDead())
        {
            OnMembersDeath();
        }
    }

    protected abstract void OnMembersDeath();

    public ICombatEntity GetRandomMember()
    {
        var aliveIndices = Enumerable.Range(0, partyMembers.Length)
            .Where(i => partyMembers[i] != null && !partyMembers[i].IsDead)
            .ToList();

        if (aliveIndices.Count == 0)
            return null;

        var originalIndex = aliveIndices.GetRandomElement();

        var finalIndex = GetTauntRedirectIndex(originalIndex);

        return GetMember(finalIndex);
    }

    public ICombatEntity GetLowestMember()
    {
        return partyMembers
            .Where(m => m != null && !m.IsDead)
            .OrderBy(m => m.CurrHP)
            .FirstOrDefault();
    }


    public List<ICombatEntity> GetAliveMembers()
    {
        return partyMembers.Where(p => p != null && !p.IsDead).ToList();
    }


    public bool AllMembersDead()
    {
        return partyMembers.All(m => m == null || m.IsDead);
    }
}

--------------------
File: /Code/Characters/EnemyGroup.cs
--------------------

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class EnemyGroup : CombatGroup
{
    protected override TargetSide Side => TargetSide.Enemies;

    public void AddEnemy(EnemyModel model)
    {
        //TODO - check array bound
        var index = model.preferPos;

        if (index == -1)
            index = Array.FindIndex(partyMembers, m => m == null);

        if (index < 0) return;

        var memberPosition = membersPos[index];
        var member = Instantiate(model.Prefab, memberPosition);
        member.SetModel(model);
        member.combatGroup = this;
        member.transform.localPosition = Vector3.zero;
        AddMember(member, index);
    }

    protected override void OnMembersDeath()
    {
    }

    public List<EnemyInstance> GetAliveEnemies()
    {
        return GetAliveMembers()
            .Select(e => e as EnemyInstance)
            .Where(e => e != null)
            .ToList();
    }


    protected override void Awake()
    {
        base.Awake();
        G.enemies = this;
    }
}

--------------------
File: /Code/Characters/ICombatEntity.cs
--------------------

using System.Collections.Generic;

public interface ICombatEntity
{
    int MaxHP { get; }

    // int Speed { get; }
    int CurrShield { get; }
    int CurrHP { get; }
    bool IsDead { get; }

    public void SetTarget(bool b);

    public bool IsPossibleTarget { get; }

    void TakeDamage(int amount);
    void Heal(int amount);
    void AddShield(int amount);

    void Kill();


    public List<IStatusEffectInteraction> statusEffects { get; }


    public int StatusTypeStacks(StatusEffectType type);

    void AddStatus(IStatusEffectInteraction statusEffect, int stacks);
}

--------------------
File: /Code/Characters/MemberModel.cs
--------------------

using UnityEngine;

[CreateAssetMenu(fileName = "New Party Member", menuName = "Party/New Party Member")]
public class MemberModel : ContentDef
{
    public int MaxHP;
    public ClassType Class;
    public int preferPos;
    public PartyMember Prefab;
    public Sprite sprite;
}

--------------------
File: /Code/Characters/PartyManager.cs
--------------------

using System.Linq;
using UnityEngine;

public class PartyManager : CombatGroup
{
    protected override TargetSide Side => TargetSide.Allies;

    protected override void Awake()
    {
        base.Awake();
        G.party = this;
    }

    protected override void OnMembersDeath()
    {
        G.main.GameLost();
    }

    public void AddMember(MemberModel model)
    {
        var index = model.preferPos;
        var memberPosition = membersPos[index];
        var member = Instantiate(model.Prefab, memberPosition);
        member.SetModel(model);
        member.CombatGroup = this;
        member.transform.localPosition = Vector3.zero;
        AddMember(member, index);
    }

    public PartyMember GetMemberByClass(ClassType classType)
    {
        return partyMembers
            .OfType<PartyMember>()
            .FirstOrDefault(p => p.state.Class == classType);
    }
}

--------------------
File: /Code/Characters/PartyMember.cs
--------------------

using System;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using Random = UnityEngine.Random;


public class MemberState
{
    public MemberModel model;
    public int CurrHP;
    public int MaxHP;
    public int currPos;
    public ClassType Class;
}


public class PartyMember : MonoBehaviour, ICombatEntity, IPointerClickHandler
{
    public MemberState state { get; private set; }
    public bool IsDead { get; private set; }
    public int CurrShield { get; private set; }
    public bool IsPossibleTarget { get; private set; }
    public CombatGroup CombatGroup;

    public int MaxHP => state.MaxHP;
    public int CurrHP => state.CurrHP;

    public List<IStatusEffectInteraction> statusEffects { get; set; } = new();

    [Header("References")] [SerializeField]
    private TMP_Text hpText;

    [SerializeField] private TMP_Text shieldText;
    [SerializeField] private SpriteRenderer shieldIconSprite;
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private SpriteRenderer highlight;

    [SerializeField] private SpriteRenderer statusEffectsIcons;
    [SerializeField] private TMP_Text statusEffectsText;


    private void Start()
    {
        UpdateVisuals();
    }

    public int StatusTypeStacks(StatusEffectType type)
    {
        var stacks = 0;
        foreach (var statusEffectInteraction in statusEffects)
        {
            if (statusEffectInteraction.Type == type)
            {
                stacks += statusEffectInteraction.Stacks;
            }
        }

        return stacks;
    }

    public void AddStatus(IStatusEffectInteraction statusEffect, int stacks)
    {
        var existing = statusEffects.FirstOrDefault(s => s.GetType() == statusEffect.GetType());

        if (existing != null)
        {
            existing.AddStacks(stacks);
            Debug.Log($"Added stack {stacks} to {statusEffect.GetType()}");
        }
        else
        {
            var instance = (IStatusEffectInteraction)Activator.CreateInstance(statusEffect.GetType());
            instance.AddStacks(stacks);
            statusEffects.Add(instance);
        }

        UpdateStatusIcon();
    }

    private void UpdateStatusIcon()
    {
        statusEffects.RemoveAll(s => s.Stacks <= 0);


        statusEffectsIcons.enabled = false;
        statusEffectsText.SetText("");

        var effect = statusEffects.FirstOrDefault();
        if (effect == null || effect.Type == StatusEffectType.None) return;

        var sprite = effect.GetSprite();
        if (sprite == null) return;

        statusEffectsIcons.enabled = true;
        statusEffectsIcons.sprite = sprite;

        if (effect.Stacks != 0)
        {
            statusEffectsText.SetText(effect.Stacks.ToString());
        }
    }


    public void SetTarget(bool b)
    {
        IsPossibleTarget = b;
    }

    public void SetState(MemberState newState)
    {
        state = newState;
        UpdateVisuals();
    }

    public void SetModel(MemberModel model)
    {
        if (model == null) return;
        var newState = new MemberState()
        {
            CurrHP = model.MaxHP,
            MaxHP = model.MaxHP,
            model = model,
            currPos = model.preferPos,
            Class = model.Class
        };

        SetState(newState);
    }

    private void Update()
    {
        SetHighlight(IsPossibleTarget);
    }

    private void SetHighlight(bool b)
    {
        if (highlight == null) return;
        highlight.gameObject.SetActive(b);
    }

    public void TakeDamage(int dmgAmount)
    {
        if (IsDead) return;
        if (dmgAmount <= 0) return;

        var remainDmg = dmgAmount;

        if (CurrShield > 0)
        {
            int absorbed = Mathf.Min(CurrShield, remainDmg);
            CurrShield -= absorbed;
            remainDmg -= absorbed;
        }

        if (remainDmg > 0)
        {
            state.CurrHP = Mathf.Max(0, state.CurrHP - remainDmg);
            float pitch = Random.Range(0.8f, 1.2f);
            G.audioSystem.PlayPitched(SoundId.SFX_PlayerDamaged, pitch);
        }
        else
        {
            G.audioSystem.Play(SoundId.SFX_DamageBlocked);
        }

        transform.DOPunchScale(new Vector3(0.2f, 0.2f, 0.2f), 0.2f);
        CheckIsDead();
        UpdateVisuals();
    }

    public void Heal(int amount)
    {
        if (IsDead) return;
        state.CurrHP = Mathf.Min(state.CurrHP + amount, state.MaxHP);
        UpdateVisuals();
        
        G.audioSystem.Play(SoundId.SFX_PlayerHealed);
    }

    public void AddShield(int amount)
    {
        if (IsDead) return;
        CurrShield += amount;
        UpdateVisuals();
        
        G.audioSystem.Play(SoundId.SFX_PlayerShielded);
    }

    public void SetShield(int amount)
    {
        if (IsDead) return;
        CurrShield = 0;
        AddShield(amount);
    }

    public void OnTurnEnd()
    {
        SetShield(0);
    }

    private void UpdateVisuals()
    {
        UpdateHpVisuals();
        UpdateShieldVisuals();
        UpdateSprite();
        UpdateStatusIcon();
    }

    private void UpdateHpVisuals()
    {
        hpText.SetText(state.CurrHP + " / " + state.MaxHP);
    }

    private void UpdateShieldVisuals()
    {
        shieldText.SetText("");
        shieldIconSprite.enabled = false;
        if (CurrShield <= 0) return;
        shieldIconSprite.enabled = true;
        shieldText.SetText(CurrShield.ToString());
    }

    private void UpdateSprite()
    {
        if (spriteRenderer == null)
        {
            Debug.LogError("SpriteRenderer is null! " + this.gameObject.name);
            return;
        }

        spriteRenderer.sprite = state.model.sprite;
    }


    private void CheckIsDead()
    {
        if (state.CurrHP > 0) return;

        IsDead = true;
        CombatGroup.CheckMemberDeath(this);
    }

    public void Kill()
    {
        TakeDamage(CurrHP);
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        G.main.TryChooseTarget(this);
    }
}

--------------------
File: /Code/D&D/ContainerBase.cs
--------------------

using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;

public abstract class ContainerBase<TDraggable> : MonoBehaviour, IDraggableContainer<TDraggable>
    where TDraggable : Draggable
{
    public event UnityAction OnContainerChanged;

    [field: SerializeField] public TDraggable AcceptedDrag { get; protected set; }
    public bool IsLocking;

    public bool IsEmpty => AcceptedDrag == null;
    [SerializeField] protected bool AnimDragOnAccept = true;

    public virtual bool TryAccept(TDraggable d, out TDraggable oldD)
    {
        oldD = AcceptedDrag;

        if (!CanAccept(d)) return false;
        
        d.transform.DOKill();

        AcceptedDrag = d;

        if (gameObject.activeInHierarchy && AnimDragOnAccept)
        {
            d.transform.DOMove(transform.position, 0.15f).SetId("Container moving draggable to centre");
            d.transform.DORotate(transform.rotation.eulerAngles, 0.15f);
        }
        else
        {
            d.transform.position = transform.position;
            d.transform.rotation = transform.rotation;
        }

        OnContainerChanged?.Invoke();
        return true;
    }


    public virtual bool TryRemove(TDraggable d)
    {
        if (!CanRemove(d)) return false;
        AcceptedDrag = null;

        OnContainerChanged?.Invoke();
        return true;
    }

    public virtual bool CanAccept(TDraggable d)
    {
        return d != null;
    }

    public bool CanAccept(MonoBehaviour d)
    {
        if (d == null) return false;
        var di = d.GetComponent<TDraggable>();
        return CanAccept(di);
    }

    public virtual bool CanRemove(TDraggable d)
    {
        return AcceptedDrag == d;
        // if (AcceptedDrag != d) return false;
        // return IsLocking;


    }

    public virtual void Clear()
    {
        if (AcceptedDrag == null) return;
        var d = AcceptedDrag;
        if (!TryRemove(AcceptedDrag)) return;

        OnClear(d);

        Destroy(d.gameObject);
    }

    protected virtual void OnClear(TDraggable d)
    {
    }

    public virtual void OnDragEnter(TDraggable d)
    {
    }

    public virtual void OnDragExit(TDraggable d)
    {
    }
}

--------------------
File: /Code/D&D/ContainerViewBase.cs
--------------------

using UnityEngine;

public abstract class ContainerViewBase<TDraggable, TContainer> : MonoBehaviour
    where TDraggable : Draggable
    where TContainer : ContainerBase<TDraggable>
{
    [Header("Base Container view References")]
    [SerializeField] protected SpriteRenderer greenHighlight;
    [SerializeField] protected TContainer containerInst;

    protected virtual void OnValidate()
    {
        if (containerInst == null) containerInst = GetComponent<TContainer>();
    }

    protected virtual void SetGreen(bool v)
    {
        if (greenHighlight == null) return;

        if (v == true && containerInst.CanAccept(G.currentDrag))
        {
            greenHighlight.enabled = true;
        }
        else
        {
            greenHighlight.enabled = false;
        }
    }

    protected virtual void Update()
    {
        SetGreen(G.currentDrag != null);
    }
}

--------------------
File: /Code/D&D/Draggable.cs
--------------------

using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.Rendering;
using UnityEngine.UIElements;

public class Draggable : MonoBehaviour, IBeginDragHandler, IEndDragHandler, IDragHandler
{
    [Header("Return animation")] [SerializeField]
    private float returnDuration = 0.2f;

    [SerializeField] private Ease returnEase = Ease.OutCubic;

    public event UnityAction OnDragBegin;
    public event UnityAction OnDragEnd;


    [SerializeField] private SortingGroup sortGroup;
    public bool IsDragging { get; private set; } = false;
    public bool IsReturning { get; private set; }


    //protected bool isPickedUp = false;
    //protected static Draggable ActivePicked = null;

    private int origLayer;
    private int origSortOrder;
    protected Camera mainCamera;
    protected Vector3 offset;
    protected Vector3 origin;
    
    public static bool DisableHoverGlobal = false;


    public float HoverLockUntil { get; protected set; } = 0.2f;

    private void OnValidate()
    {
        if (sortGroup == null) sortGroup = GetComponent<SortingGroup>();
    }

    private void Start()
    {
        mainCamera = Camera.main;
    }

    public virtual void OnBeginDrag(PointerEventData eventData)
    {
        if (!CanDrag()) return;
        if (G.HUD != null && G.HUD.tooltip != null) G.HUD.tooltip.PushBlock();
        
        if (IsReturning)
        {
            transform.DOKill();
            IsReturning = false;
        }
        else
        {
            transform.DOKill();
        }
        
        G.currentDrag = this;
        IsDragging = true;

        origLayer = gameObject.layer;
        gameObject.layer = LayerMask.NameToLayer("Ignore Raycast");
        if (sortGroup != null)
        {
            origSortOrder = sortGroup.sortingOrder;
            sortGroup.sortingOrder = 9999;
        }

        origin = transform.position;

        var worldPos = mainCamera.ScreenToWorldPoint(eventData.position);
        worldPos.z = transform.position.z;
        offset = transform.position - worldPos;
        
        DisableHoverGlobal = true;
        OnDragBegin?.Invoke();
    }


    protected virtual bool CanDrag()
    {
        return true;
    }

    public virtual void OnDrag(PointerEventData eventData)
    {
        if (!IsDragging) return;
        if (!CanDrag()) return;


        UpdatePosToCursor();
    }

    protected virtual void UpdatePosToCursor()
    {
        var cursorWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
        cursorWorldPos.z = transform.position.z;
        transform.position = cursorWorldPos + offset;
    }

    public virtual void OnEndDrag(PointerEventData eventData)
    {
        if (!IsDragging) return;
        if (!CanDrag()) return;
        LockHover();
        Release();
        
        DisableHoverGlobal = false;
        OnDropped(eventData);
    }

    protected virtual void Release()
    {
        G.currentDrag = null;
        IsDragging = false;

        gameObject.layer = origLayer;
        if (sortGroup != null) sortGroup.sortingOrder = origSortOrder;

        if (G.HUD != null && G.HUD.tooltip != null) G.HUD.tooltip.PopBlock();

        OnDragEnd?.Invoke();
    }

    protected virtual void OnDropped(PointerEventData eventData)
    {
    }

    public void ReturnToOrigin()
    {
        transform.DOKill();

        IsReturning = true;

        transform.DOMove(origin, returnDuration)
            .SetEase(returnEase)
            .OnComplete(() => { IsReturning = false; });
    }


    public void LockHover(float seconds = 0.3f)
    {
        HoverLockUntil = Mathf.Max(HoverLockUntil, Time.time + seconds);
    }

    protected virtual void OnDestroy()
    {
        transform.DOKill();
    }

    public virtual void OnPointerClick(PointerEventData eventData)
    {
        //if (eventData.dragging) return;
        //if (ActivePicked != null && ActivePicked != this) return;

        //if (!isPickedUp)
        //{
        //    OnBeginDrag(eventData);
        //    isPickedUp = true;
        //    ActivePicked = this;
        //    eventData.Use();
        //    Debug.Log("Begin drag with click " + isPickedUp + " " + ActivePicked.name);
        //}
        //else
        //{
        //    OnEndDrag(eventData);
        //    isPickedUp = false;
        //    ActivePicked = null;
        //    eventData.Use();
        //}
    }

    //private void Update()
    //{
    //    if (isPickedUp)
    //    {
    //        UpdatePosToCursor();
    //    }
    //}

    //private void OnDisable()
    //{
    //    if (ActivePicked == this) ActivePicked = null;
    //    isPickedUp = false;
    //    IsDragging = false;
    //}
}

--------------------
File: /Code/D&D/DraggableUtil.cs
--------------------

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

public static class DraggableUtil<TDraggable>
    where TDraggable : Draggable
{
    public static IDraggableContainer<TDraggable> FindContainer(TDraggable draggable, PointerEventData eventData = null)
    {
        if (eventData != null)
        {
            var uiCont = FindContainerUI(eventData, draggable);
            if (uiCont != null)
            {
                return uiCont;
            }
        }

        return FindContainerPhysics(draggable);
    }

    private static IDraggableContainer<TDraggable> FindContainerUI(PointerEventData eventData, TDraggable draggable)
    {
        if (EventSystem.current == null) return null;

        var results = new List<RaycastResult>();
        EventSystem.current.RaycastAll(eventData, results);

        foreach (var r in results)
        {
            if (r.gameObject == null) continue;
            if (!r.gameObject.TryGetComponent<IDraggableContainer<TDraggable>>(out var cont)) continue;
            if (cont == draggable) continue;

            if (!cont.CanAccept(draggable)) continue;

            return cont;
        }

        return null;
    }

    private static IDraggableContainer<TDraggable> FindContainerPhysics(TDraggable draggable)
    {
        var cols = Physics2D.OverlapCircleAll(draggable.transform.position, 0.5f);

        IDraggableContainer<TDraggable> best = null;
        float bestDist = float.MaxValue;

        foreach (var overlapCol in cols)
        {
            if (!overlapCol.TryGetComponent<IDraggableContainer<TDraggable>>(out var dragContainer)) continue;
            if (overlapCol.gameObject == draggable.gameObject) continue;

            if (dragContainer is not MonoBehaviour acceptorMB) continue;

            float dist = Vector3.Distance(draggable.transform.position, acceptorMB.transform.position);
            if (dist < bestDist)
            {
                bestDist = dist;
                best = dragContainer;
            }
        }

        return best;
    }
}

--------------------
File: /Code/D&D/DraggableWContainer.cs
--------------------

using System.Collections;
using UnityEngine;
using UnityEngine.EventSystems;

public abstract class DraggableWContainer<TD, TC> : Draggable
    where TD : DraggableWContainer<TD, TC>
    where TC : class, IDraggableContainer<TD>
{
    public virtual TC CurrContainer { get; protected set; }
    public virtual IDraggableOwner<TD> Owner { get; protected set; }
    public Coroutine PutInContCoroutine { get; protected set; }
    private TD selfCasted => this as TD;

    public bool IsLocked { get; protected set; }


    protected override bool CanDrag()
    {
        if (!base.CanDrag()) return false;
        return !IsLocked;
    }

    public void SetLocked(bool isLocked)
    {
        IsLocked = isLocked;
    }


    public virtual void SetOwner(IDraggableOwner<TD> newOwner)
    {
        if (Owner == newOwner) return;

        var prev = Owner;

        prev?.OnDragExit(selfCasted);

        Owner = newOwner;

        Owner?.OnDragEnter(selfCasted);
    }

    protected virtual void SetContainer(TC newContainer)
    {
        CurrContainer = newContainer;

        if (newContainer is IDraggableOwner<TD> owner)
        {
            SetOwner(owner);
        }
    }


    protected override void OnDropped(PointerEventData eventData)
    {
        base.OnDropped(eventData);

        var rawContainer = DraggableUtil<TD>.FindContainer(selfCasted, eventData);
        var targetCont = rawContainer as TC;

        PutInContainer(targetCont);
    }

    public void PutInContainer(TC targetCont)
    {
        if (PutInContCoroutine != null)
        {
            StopCoroutine(PutInContCoroutine);
        }

        PutInContCoroutine = StartCoroutine(PutInContainerSequence(targetCont));
    }

    protected virtual IEnumerator PutInContainerSequence(TC targetCont)
    {
        var sourceCont = CurrContainer;

        if (!ValidateMove(sourceCont, targetCont))
        {
            ReturnToOrigin();
            PutInContCoroutine = null;
            yield break;
        }

        if (sourceCont != null && !ReferenceEquals(sourceCont, targetCont))
        {
            sourceCont.TryRemove(selfCasted);
        }

        if (!targetCont.TryAccept(selfCasted, out _))
        {
            ReturnToOrigin();
            PutInContCoroutine = null;
            yield break;
        }

        SetContainer(targetCont);

        PutInContCoroutine = null;
        yield break;
    }



    protected virtual bool ValidateMove(TC sourceCont, TC targetCont)
    {
        if (targetCont == null) return false;
        if (sourceCont != null && !sourceCont.CanRemove(selfCasted)) return false;
        if (!targetCont.CanAccept(selfCasted)) return false;
        return true;
    }
}

--------------------
File: /Code/D&D/Interfaces/IDraggableContainer.cs
--------------------

using System;
using UnityEngine.Events;

public interface IDraggableContainer<TDraggable> : IDraggableOwner<TDraggable>
    where TDraggable : Draggable
{
    event UnityAction OnContainerChanged;

    bool IsEmpty { get; }

    bool CanAccept(TDraggable d);

    bool CanRemove(TDraggable d);

    bool TryAccept(TDraggable d, out TDraggable oldD);

    bool TryRemove(TDraggable d);

    void Clear();
}


public interface IDraggableOwner<TD>
    where TD : Draggable
{
    void OnDragEnter(TD d);
    void OnDragExit(TD d);
}

--------------------
File: /Code/DefaultSystems/AnalyticSystem/AnalyticsSystem.cs
--------------------

using System.Threading.Tasks;
using Unity.Services.Analytics;
using Unity.Services.Core;
using UnityEngine.UnityConsent;

public static class AnalyticsSystem
{
    private static bool IsInit = false;

    public static async Task Init()
    {
#if !UNITY_EDITOR

        await UnityServices.InitializeAsync();

        var state = new ConsentState
        {
            AnalyticsIntent = ConsentStatus.Granted,
            AdsIntent = ConsentStatus.Denied
        };

        EndUserConsent.SetConsentState(state);
        IsInit = true;

#else
        await UnityServices.InitializeAsync();
#endif
    }

    public static void OnLevelChanged(int levelIndex, string levelName)
    {
        if (!IsInit) return;
        const string eventName = "level_changed";
        var customEvent = new CustomEvent(eventName)
        {
            { "level_index", levelIndex },
            { "level_name", levelName }
        };
        AnalyticsService.Instance.RecordEvent(customEvent);
    }

    public static void OnGameEnded(string result, int totalLevelsPassed)
    {
        if (!IsInit) return;
        const string eventName = "game_end";
        var customEvent = new CustomEvent(eventName)
        {
            { "result", result },
            { "total_levels_passed", totalLevelsPassed }
        };
        AnalyticsService.Instance.RecordEvent(customEvent);
    }
}

--------------------
File: /Code/DefaultSystems/AudioSystem/AudioPlayers/AmbientPlayer.cs
--------------------

using UnityEngine;

public class AmbientPlayer : IAudioPlayer
{
    public AudioType Type => AudioType.Ambient;
    private AudioSystem audioSystem;
    private AudioSource audioSource;
    private float volume = 1.0f;
    private SoundEntity currentSound;
    private bool isMuted = false;

    public AmbientPlayer(AudioSystem audioSystem)
    {
        this.audioSystem = audioSystem;
        Init();
    }

    private void Init()
    {
        audioSource = audioSystem.gameObject.AddComponent<AudioSource>();
        audioSource.playOnAwake = false;
    }

    public void Play(SoundEntity sound)
    {
        if (sound == null) return;
        if (audioSource == null) return;

        currentSound = sound;
        var clip = sound.GetClip();

        audioSource.clip = clip;
        audioSource.loop = true;
        audioSource.volume = volume * sound.Volume;
        if (!isMuted) audioSource.Play();
    }

    public void Stop()
    {
        audioSource.Stop();
        audioSource.clip = null;
        currentSound = null;
    }

    //public void SetMute(bool isMuted)
    //{
    //    if (audioSource == null) return;
    //    this.isMuted = isMuted;

    //    if (isMuted && audioSource.isPlaying) audioSource.Stop();
    //    else if (currentSound != null) Play(currentSound);
    //}

    public void SetVolume(float volume)
    {
        this.volume = Mathf.Clamp01(volume);

        //if (volume <= 0.0f) SetMute(true);
        //else if (volume > 0 && isMuted) SetMute(false);

        if (audioSource.clip != null && audioSource.isPlaying)
        {
            audioSource.volume = volume * currentSound.Volume;
        }
    }
}

--------------------
File: /Code/DefaultSystems/AudioSystem/AudioPlayers/IAudioPlayer.cs
--------------------

public interface IAudioPlayer
{
    AudioType Type { get; }

    void Play(SoundEntity sound);

    void Stop();

    //void SetMute(bool isMuted);

    void SetVolume(float volume);
}

--------------------
File: /Code/DefaultSystems/AudioSystem/AudioPlayers/MusicPlayer.cs
--------------------

using System.Collections;
using UnityEngine;

public class MusicPlayer : IAudioPlayer
{
    public AudioType Type => AudioType.Music;
    private AudioSystem audioSystem;

    private AudioSource sourceA;
    private AudioSource sourceB;
    private bool isAActive = false;
    private bool isMuted = false;
    private float volume = 1.0f;

    private SoundEntity currentSound;

    private AudioSource GetCurrentSource() => isAActive ? sourceA : sourceB;

    private AudioSource GetInactiveSource() => isAActive ? sourceB : sourceA;

    private Coroutine fadeRoutine;

    public MusicPlayer(AudioSystem audioSystem)
    {
        this.audioSystem = audioSystem;
        Init();
    }

    private void Init()
    {
        var audioGO = audioSystem.gameObject;

        sourceA = AddMusicSource(audioGO);
        sourceB = AddMusicSource(audioGO);
    }

    private AudioSource AddMusicSource(GameObject gameObject)
    {
        var source = gameObject.AddComponent<AudioSource>();
        source.playOnAwake = false;
        source.loop = true;

        return source;
    }

    public void Play(SoundEntity sound)
    {
        PlayWithFade(sound);
    }

    public void PlayWithFade(SoundEntity sound, float fadeDuration = 0f)
    {
        if (sourceA == null || sourceB == null) return;
        if (sound == null) return;

        var currentSource = GetCurrentSource();
        var nextSource = GetInactiveSource();

        currentSound = sound;

        nextSource.clip = sound.GetClip();
        float targetVolume = audioSystem.MusicVolume * sound.Volume;

        if (fadeDuration <= 0f)
        {
            currentSource.Stop();
            nextSource.volume = targetVolume;
            nextSource.Play();
        }
        else
        {
            nextSource.volume = 0f;
            if (!isMuted) nextSource.Play();
            StartFadeRoutine(currentSource, nextSource, targetVolume, fadeDuration);
        }

        isAActive = !isAActive;
    }

    private void StartFadeRoutine(AudioSource from, AudioSource to, float targetVolume, float duration)
    {
        if (fadeRoutine != null) audioSystem.StopCoroutine(fadeRoutine);

        fadeRoutine = audioSystem.StartCoroutine(FadeRoutine(from, to, targetVolume, duration));
    }

    private IEnumerator FadeRoutine(AudioSource from, AudioSource to, float targetVolume, float duration)
    {
        float time = 0f;
        float fromStartVolume = from.volume;

        while (time < duration)
        {
            time += Time.deltaTime;
            float t = time / duration;

            from.volume = Mathf.Lerp(fromStartVolume, 0f, t);
            to.volume = Mathf.Lerp(0, targetVolume, t);
            yield return null;
        }

        from.Stop();
        from.volume = 0f;
        to.volume = targetVolume;
    }

    public void Stop()
    {
        if (sourceA.isPlaying) sourceA.Stop();
        if (sourceB.isPlaying) sourceB.Stop();

        if (fadeRoutine != null)
        {
            audioSystem.StopCoroutine(fadeRoutine);
            fadeRoutine = null;
        }
    }

    //public void SetMute(bool isMuted)
    //{
    //    if (sourceA == null || sourceB == null) return;
    //    this.isMuted = isMuted;

    //    if (isMuted && GetCurrentSource().isPlaying) GetCurrentSource().Stop();
    //    else if (currentSound != null) Play(currentSound);
    //}

    public void SetVolume(float volume)
    {
        this.volume = Mathf.Clamp01(volume);

        //if (volume <= 0.0f) SetMute(true);
        //else if (volume > 0 && isMuted) SetMute(false);

        if (GetCurrentSource().isPlaying && GetCurrentSource().clip != null)
        {
            GetCurrentSource().volume = volume * currentSound.Volume;
        }
    }
}

--------------------
File: /Code/DefaultSystems/AudioSystem/AudioPlayers/SFXPlayer.cs
--------------------

using UnityEngine;

public class SFXPlayer : IAudioPlayer
{
    private AudioSystem audioSystem;
    public AudioType Type => AudioType.SFX;
    private SFXSourcesPool sourcePool;
    private float volume = 1.0f;
    private bool isMuted = false;

    public SFXPlayer(AudioSystem audioSystem, int initPoolSize, int maxPoolSize)
    {
        sourcePool = new SFXSourcesPool(audioSystem, initPoolSize, maxPoolSize);
        this.audioSystem = audioSystem;
    }

    public void Play(SoundEntity sound)
    {
        PlayPitched(sound, 1f, 1f);
    }
    
    public void PlayPitched(SoundEntity sound, float pitch, float volumeMul = 1f)
    {
        if (isMuted) return;
        if (sound == null) return;

        var clip = sound.GetClip();
        var source = sourcePool.GetAvailableAudioSource();
        if (source == null) return;

        source.clip = clip;
        source.volume = audioSystem.SfxVolume * sound.Volume * volumeMul;
        source.pitch = pitch;
        source.Play();

        sourcePool.ReleaseSource(source, clip);
    }
    

    public void Stop()
    {
        sourcePool.ReleaseAllSources();
    }

    //public void SetMute(bool isMuted)
    //{
    //    this.isMuted = isMuted;

    //    if (isMuted) Stop();
    //}

    public void SetVolume(float volume)
    {
        this.volume = Mathf.Clamp01(volume);

        //if (volume <= 0.0f) SetMute(true);
        //else if (volume > 0 && isMuted) SetMute(false);
    }
}

--------------------
File: /Code/DefaultSystems/AudioSystem/AudioPlayers/SFXSourcesPool.cs
--------------------

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SFXSourcesPool
{
    private GameObject audioObject;
    private AudioSystem audioSystem;
    private int initialPoolSize = 10;
    private int maxPoolSize = 24;

    private List<AudioSource> SFXSources = new List<AudioSource>();

    public SFXSourcesPool(AudioSystem audioSystem, int initSize, int maxSize)
    {
        initialPoolSize = initSize;
        maxPoolSize = maxSize;
        audioObject = audioSystem.gameObject;
        this.audioSystem = audioSystem;
        Init();
    }

    private void Init()
    {
        for (int i = 0; i < initialPoolSize; i++)
        {
            var sfxSouce = audioObject.AddComponent<AudioSource>();
            sfxSouce.playOnAwake = false;
            SFXSources.Add(sfxSouce);
        }
    }

    public AudioSource GetAvailableAudioSource()
    {
        foreach (var src in SFXSources)
        {
            if (!src.isPlaying || src.clip == null) return src;
        }
        if (AddAudioSource())
        {
            return SFXSources[^1];
        }

        return null;
    }

    private bool AddAudioSource()
    {
        if (SFXSources.Count > maxPoolSize)
        {
            Debug.LogWarning("Пул SFX перегружен");
            return false;
        }

        var newSource = audioObject.AddComponent<AudioSource>();
        newSource.playOnAwake = false;
        SFXSources.Add(newSource);
        return true;
    }

    public void ReleaseAllSources()
    {
        foreach (var src in SFXSources)
            src.Stop();
    }

    public void ReleaseSource(AudioSource source, AudioClip initialClip)
    {
        audioSystem.StartCoroutine(ReleaseRoutine(source, initialClip));
    }

    private IEnumerator ReleaseRoutine(AudioSource source, AudioClip initialClip)
    {
        yield return new WaitForSeconds(initialClip.length);

        if (source.clip != initialClip) yield break;
        source.Stop();
        source.clip = null;
        source.loop = false;
    }
}

--------------------
File: /Code/DefaultSystems/AudioSystem/AudioSystem.cs
--------------------

using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(SoundsLibrary))]
public class AudioSystem : MonoBehaviour
{
    public const string MUSIC_VOL_KEY = "Music_volume";
    public const string SFX_VOL_KEY = "SFX_volume";
    public const string AMBIENT_VOL_KEY = "Ambient_volume";

    [SerializeField] private SoundsLibrary soundsLibrary;
    private Dictionary<AudioType, IAudioPlayer> audioPlayers = new();

    public int initSFXPoolSize = 10;
    public int maxSFXPoolSize = 24;

    [Range(0f, 1f)] public float MusicVolume = 1f;
    [Range(0f, 1f)] public float SfxVolume = 1f;
    [Range(0f, 1f)] public float AmbientVolume = 1f;

    private void OnValidate()
    {
        if (soundsLibrary == null) soundsLibrary = GetComponent<SoundsLibrary>();
    }

    private void Awake()
    {
        DontDestroyOnLoad(gameObject);

        if (G.audioSystem != null && G.audioSystem != this)
        {
            Destroy(gameObject);
            return;
        }

        G.audioSystem = this;
        Init();
        MusicVolume = PlayerPrefs.GetFloat(MUSIC_VOL_KEY, MusicVolume);
        AmbientVolume = PlayerPrefs.GetFloat(AMBIENT_VOL_KEY, AmbientVolume);
        SfxVolume = PlayerPrefs.GetFloat(SFX_VOL_KEY, SfxVolume);
    }

    private void Init()
    {
        audioPlayers[AudioType.SFX] = new SFXPlayer(this, initSFXPoolSize, maxSFXPoolSize);
        audioPlayers[AudioType.Ambient] = new AmbientPlayer(this);
        audioPlayers[AudioType.Music] = new MusicPlayer(this);
    }

    public void Play(SoundId soundID)
    {
        var soundEntity = soundsLibrary.GetSound(soundID);
        if (soundEntity == null)
        {
            Debug.LogWarning("No sounds found with id: " + soundID.ToString());
            return;
        }

        if (audioPlayers.TryGetValue(soundEntity.Type, out IAudioPlayer player))
        {
            player.Play(soundEntity);
        }
    }
    
    public void PlayPitched(SoundId soundID, float pitch, float volumeMul = 1f)
    {
        var soundEntity = soundsLibrary.GetSound(soundID);
        if (soundEntity == null)
        {
            Debug.LogWarning("No sounds found with id: " + soundID);
            return;
        }
        
        if (soundEntity.Type != AudioType.SFX)
        {
            Play(soundID);
            return;
        }

        if (audioPlayers.TryGetValue(AudioType.SFX, out IAudioPlayer player))
        {
            if (player is SFXPlayer sfxPlayer)
            {
                sfxPlayer.PlayPitched(soundEntity, pitch, volumeMul);
            }
            else
            {
                player.Play(soundEntity);
            }
        }
        else
        {
            Debug.LogWarning("No SFXPlayer found in AudioSystem for pitched play.");
        }
    }


    public void StopAll()
    {
        foreach (var player in audioPlayers.Values)
        {
            player.Stop();
        }
    }

    public void Stop(AudioType type)
    {
        if (audioPlayers.TryGetValue(type, out IAudioPlayer player))
        {
            player.Stop();
        }
    }

    public void PlayMusicWithFade(SoundId soundID, float fadeDur = 1f)
    {
        var soundEntity = soundsLibrary.GetSound(soundID);

        if (audioPlayers[soundEntity.Type] is MusicPlayer musicPlayer)
        {
            musicPlayer.PlayWithFade(soundEntity, fadeDur);
        }
    }

    public void SetMusicVolume(float volume)
    {
        MusicVolume = volume;

        SetPlayerVolume(volume, AudioType.Music);
    }

    public void SetAmbientVolume(float volume)
    {
        AmbientVolume = volume;

        SetPlayerVolume(volume, AudioType.Ambient);
    }

    public void SetSFXVolume(float volume)
    {
        SfxVolume = volume;

        SetPlayerVolume(volume, AudioType.SFX);
    }

    private void SetPlayerVolume(float volume, AudioType audioType)
    {
        if (audioPlayers.TryGetValue(audioType, out IAudioPlayer player))
        {
            player.SetVolume(volume);
        }

        UpdateVolumePrefs();
    }

    private void UpdateVolumePrefs()
    {
        PlayerPrefs.SetFloat(MUSIC_VOL_KEY, MusicVolume);
        PlayerPrefs.SetFloat(AMBIENT_VOL_KEY, AmbientVolume);
        PlayerPrefs.SetFloat(SFX_VOL_KEY, SfxVolume);
        PlayerPrefs.Save();
    }

    private void OnApplicationQuit()
    {
        UpdateVolumePrefs();
    }
}

--------------------
File: /Code/DefaultSystems/AudioSystem/AudioType.cs
--------------------

public enum AudioType
{
    SFX,
    Ambient,
    Music
}

--------------------
File: /Code/DefaultSystems/AudioSystem/Editor/SoundsDataContainerEditor.cs
--------------------

using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(SoundsDataContainer))]
public class SoundsDataContainerEditor : Editor
{
    private SerializedProperty soundsEntitiesProp;

    // Foldout по каждому SoundEntity (индекс -> состояние). Поддерживаем при reorder.
    private bool[] foldoutStates;

    // Foldout по группам типа
    private readonly Dictionary<int, bool> typeFoldouts = new Dictionary<int, bool>();

    // Поиск
    private string searchQuery = string.Empty;

    // Данные enum-типа (type)
    private string[] soundTypeDisplayNames;
    private int soundTypeCount;

    // Drag&Drop (перетаскивание SoundEntity)
    private const string DragKey = "SoundsDataContainerEditor.SoundEntityIndex";

    // Стили инициализируем лениво
    private GUIStyle headerStyle;
    private GUIStyle subHeaderStyle;
    private GUIStyle boxStyle;
    private GUIStyle groupStyle;
    private GUIStyle dragHandleStyle;

    private void OnEnable()
    {
        soundsEntitiesProp = serializedObject.FindProperty("soundsEntities");

        ResolveSoundTypeEnumInfo();
        EnsureFoldoutStatesSize();
    }

    private void ResolveSoundTypeEnumInfo()
    {
        // 1) Если есть элементы — enumDisplayNames достанем напрямую.
        if (soundsEntitiesProp != null && soundsEntitiesProp.arraySize > 0)
        {
            var first = soundsEntitiesProp.GetArrayElementAtIndex(0);
            var typeProp = first.FindPropertyRelative("type");
            if (typeProp != null && typeProp.propertyType == SerializedPropertyType.Enum)
            {
                soundTypeDisplayNames = typeProp.enumDisplayNames;
                soundTypeCount = soundTypeDisplayNames != null ? soundTypeDisplayNames.Length : 0;
                return;
            }
        }

        // 2) Если список пустой — пытаемся через reflection достать enum тип из модели.
        try
        {
            var containerType = target.GetType();
            var field = containerType.GetField("soundsEntities", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            if (field == null)
            {
                soundTypeDisplayNames = Array.Empty<string>();
                soundTypeCount = 0;
                return;
            }

            var listType = field.FieldType;
            Type elementType = null;

            if (listType.IsArray)
                elementType = listType.GetElementType();
            else if (listType.IsGenericType)
                elementType = listType.GetGenericArguments()[0];

            if (elementType == null)
            {
                soundTypeDisplayNames = Array.Empty<string>();
                soundTypeCount = 0;
                return;
            }

            // Ищем поле/свойство "type" в элементе
            var typeField = elementType.GetField("type", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            Type enumType = typeField != null ? typeField.FieldType : null;

            if (enumType == null)
            {
                var typePropInfo = elementType.GetProperty("type", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                enumType = typePropInfo != null ? typePropInfo.PropertyType : null;
            }

            if (enumType != null && enumType.IsEnum)
            {
                soundTypeDisplayNames = Enum.GetNames(enumType);
                soundTypeCount = soundTypeDisplayNames.Length;
            }
            else
            {
                soundTypeDisplayNames = Array.Empty<string>();
                soundTypeCount = 0;
            }
        }
        catch
        {
            soundTypeDisplayNames = Array.Empty<string>();
            soundTypeCount = 0;
        }
    }

    private void EnsureFoldoutStatesSize()
    {
        int size = soundsEntitiesProp != null ? soundsEntitiesProp.arraySize : 0;

        if (foldoutStates == null)
        {
            foldoutStates = new bool[size];
            return;
        }

        if (foldoutStates.Length == size) return;

        var newArr = new bool[size];
        int copyLen = Mathf.Min(foldoutStates.Length, size);
        Array.Copy(foldoutStates, newArr, copyLen);
        foldoutStates = newArr;
    }

    private void InitializeStyles()
    {
        if (headerStyle == null)
        {
            headerStyle = new GUIStyle(EditorStyles.boldLabel)
            {
                fontSize = 14,
                margin = new RectOffset(5, 5, 10, 5)
            };
        }

        if (subHeaderStyle == null)
        {
            subHeaderStyle = new GUIStyle(EditorStyles.boldLabel)
            {
                fontSize = 12
            };
        }

        if (boxStyle == null)
        {
            boxStyle = new GUIStyle(EditorStyles.helpBox)
            {
                padding = new RectOffset(10, 10, 10, 10),
                margin = new RectOffset(5, 5, 5, 5)
            };
        }

        if (groupStyle == null)
        {
            groupStyle = new GUIStyle(EditorStyles.helpBox)
            {
                padding = new RectOffset(10, 10, 8, 8),
                margin = new RectOffset(5, 5, 8, 8)
            };
        }

        if (dragHandleStyle == null)
        {
            dragHandleStyle = new GUIStyle(EditorStyles.miniLabel)
            {
                alignment = TextAnchor.MiddleCenter,
                fontSize = 12
            };
        }
    }

    public override void OnInspectorGUI()
    {
        InitializeStyles();

        serializedObject.Update();
        EnsureFoldoutStatesSize();

        EditorGUILayout.LabelField("Звуковой пул", headerStyle);

        // Верхняя панель
        EditorGUILayout.BeginHorizontal();
        if (GUILayout.Button("Добавить новый звук", GUILayout.Height(26)))
        {
            AddNewSoundEntity();
            GUIUtility.ExitGUI();
        }

        GUILayout.FlexibleSpace();

        // Быстрые действия
        if (GUILayout.Button("Раскрыть все", GUILayout.Width(100), GUILayout.Height(26)))
        {
            for (int i = 0; i < foldoutStates.Length; i++) foldoutStates[i] = true;
        }
        if (GUILayout.Button("Свернуть все", GUILayout.Width(100), GUILayout.Height(26)))
        {
            for (int i = 0; i < foldoutStates.Length; i++) foldoutStates[i] = false;
        }
        EditorGUILayout.EndHorizontal();

        EditorGUILayout.Space(8);

        // Поиск
        EditorGUILayout.BeginHorizontal();
        EditorGUILayout.LabelField("Поиск", GUILayout.Width(40));
        searchQuery = EditorGUILayout.TextField(searchQuery);
        if (GUILayout.Button("×", GUILayout.Width(22)))
        {
            searchQuery = string.Empty;
            GUI.FocusControl(null);
        }
        EditorGUILayout.EndHorizontal();

        EditorGUILayout.Space(10);

        // Если не смогли определить enum типов — показываем плоский список, но с drag&drop reorder.
        if (soundTypeCount <= 0)
        {
            EditorGUILayout.HelpBox(
                "Не удалось определить список типов звука (enum). Показываю общий список без группировки.",
                MessageType.Warning);
            DrawFlatListWithDrag();
        }
        else
        {
            DrawGroupedByType();
        }

        serializedObject.ApplyModifiedProperties();
    }

    private void DrawGroupedByType()
    {
        // Собираем индексы по типам, с учетом фильтра поиска
        var indicesByType = new Dictionary<int, List<int>>();
        for (int t = 0; t < soundTypeCount; t++)
            indicesByType[t] = new List<int>();

        string q = string.IsNullOrWhiteSpace(searchQuery) ? null : searchQuery.Trim().ToLowerInvariant();

        for (int i = 0; i < soundsEntitiesProp.arraySize; i++)
        {
            var el = soundsEntitiesProp.GetArrayElementAtIndex(i);
            var typeProp = el.FindPropertyRelative("type");
            if (typeProp == null || typeProp.propertyType != SerializedPropertyType.Enum)
                continue;

            int typeIndex = Mathf.Clamp(typeProp.enumValueIndex, 0, soundTypeCount - 1);

            if (q != null)
            {
                var idProp = el.FindPropertyRelative("soundId");
                var idText = GetPropertyAsSearchableText(idProp);
                if (string.IsNullOrEmpty(idText) || !idText.ToLowerInvariant().Contains(q))
                    continue;
            }

            indicesByType[typeIndex].Add(i);
        }

        // Рисуем группы в порядке enum
        for (int t = 0; t < soundTypeCount; t++)
        {
            string typeName = soundTypeDisplayNames[t];
            if (!typeFoldouts.ContainsKey(t))
                typeFoldouts[t] = true;

            EditorGUILayout.BeginVertical(groupStyle);

            // Заголовок группы
            EditorGUILayout.BeginHorizontal();
            typeFoldouts[t] = EditorGUILayout.Foldout(typeFoldouts[t], $"{typeName}  ({indicesByType[t].Count})", true);
            GUILayout.FlexibleSpace();
            if (GUILayout.Button("+", GUILayout.Width(28), GUILayout.Height(18)))
            {
                AddNewSoundEntity(typeIndexOverride: t);
                GUIUtility.ExitGUI();
            }
            EditorGUILayout.EndHorizontal();

            // Drop-zone для смены типа перетаскиванием
            Rect dropRect = GUILayoutUtility.GetRect(0f, 18f, GUILayout.ExpandWidth(true));
            GUI.Box(dropRect, "Перетащи сюда звук, чтобы сменить тип", EditorStyles.centeredGreyMiniLabel);
            HandleTypeDrop(dropRect, targetTypeIndex: t);

            if (typeFoldouts[t])
            {
                if (indicesByType[t].Count == 0)
                {
                    EditorGUILayout.HelpBox("В этой группе пока нет звуков.", MessageType.Info);
                }
                else
                {
                    for (int k = 0; k < indicesByType[t].Count; k++)
                    {
                        int indexInArray = indicesByType[t][k];
                        DrawSoundEntity(indexInArray, groupTypeIndex: t);
                        EditorGUILayout.Space(5);
                    }
                }
            }

            EditorGUILayout.EndVertical();
        }

        if (!string.IsNullOrWhiteSpace(searchQuery))
        {
            EditorGUILayout.HelpBox("Показаны только элементы, которые совпали с поиском по soundId.", MessageType.None);
        }
    }

    private void DrawFlatListWithDrag()
    {
        if (soundsEntitiesProp.arraySize == 0)
        {
            EditorGUILayout.HelpBox("Нет добавленных звуков. Нажмите кнопку выше, чтобы добавить.", MessageType.Info);
            return;
        }

        string q = string.IsNullOrWhiteSpace(searchQuery) ? null : searchQuery.Trim().ToLowerInvariant();

        for (int i = 0; i < soundsEntitiesProp.arraySize; i++)
        {
            var el = soundsEntitiesProp.GetArrayElementAtIndex(i);
            if (q != null)
            {
                var idProp = el.FindPropertyRelative("soundId");
                var idText = GetPropertyAsSearchableText(idProp);
                if (string.IsNullOrEmpty(idText) || !idText.ToLowerInvariant().Contains(q))
                    continue;
            }

            DrawSoundEntity(i, groupTypeIndex: -1);
            EditorGUILayout.Space(5);
        }

        if (!string.IsNullOrWhiteSpace(searchQuery))
        {
            EditorGUILayout.HelpBox("Показаны только элементы, которые совпали с поиском по soundId.", MessageType.None);
        }
    }

    private void DrawSoundEntity(int indexInArray, int groupTypeIndex)
    {
        EnsureFoldoutStatesSize();
        if (indexInArray < 0 || indexInArray >= soundsEntitiesProp.arraySize) return;

        SerializedProperty soundEntityProp = soundsEntitiesProp.GetArrayElementAtIndex(indexInArray);
        SerializedProperty soundIdProp = soundEntityProp.FindPropertyRelative("soundId");
        SerializedProperty typeProp = soundEntityProp.FindPropertyRelative("type");
        SerializedProperty clipsProp = soundEntityProp.FindPropertyRelative("Clips");

        EditorGUILayout.BeginVertical(boxStyle);

        // --- Header row ---
        Rect headerRect = GUILayoutUtility.GetRect(0f, EditorGUIUtility.singleLineHeight, GUILayout.ExpandWidth(true));

        float x = headerRect.x;
        float y = headerRect.y;
        float h = headerRect.height;

        Rect foldRect = new Rect(x, y, 16f, h);
        x += foldRect.width;

        Rect handleRect = new Rect(x, y, 18f, h);
        x += handleRect.width + 2f;

        float rightDelW = 22f;
        float rightClipsW = 80f;
        float rightTypeW = 120f;

        Rect delRect = new Rect(headerRect.xMax - rightDelW, y, rightDelW, h);
        Rect clipsRect = new Rect(delRect.xMin - 4f - rightClipsW, y, rightClipsW, h);
        Rect typeLabelRect = new Rect(clipsRect.xMin - 4f - rightTypeW, y, rightTypeW, h);

        Rect idRect = new Rect(x, y, Mathf.Max(40f, typeLabelRect.xMin - 6f - x), h);

        foldoutStates[indexInArray] = EditorGUI.Foldout(foldRect, foldoutStates[indexInArray], GUIContent.none, true);
        GUI.Label(handleRect, "≡", dragHandleStyle);

        if (soundIdProp != null)
            EditorGUI.PropertyField(idRect, soundIdProp, GUIContent.none);
        else
            EditorGUI.LabelField(idRect, "soundId не найден");

        string typeName = typeProp != null && typeProp.propertyType == SerializedPropertyType.Enum
            ? typeProp.enumDisplayNames[typeProp.enumValueIndex]
            : "?";

        int clipsCount = clipsProp != null && clipsProp.isArray ? clipsProp.arraySize : 0;

        EditorGUI.LabelField(typeLabelRect, $"Тип: {typeName}", EditorStyles.miniLabel);
        EditorGUI.LabelField(clipsRect, $"Клипов: {clipsCount}", EditorStyles.miniLabel);

        if (GUI.Button(delRect, "×"))
        {
            DeleteSoundEntity(indexInArray);
            GUIUtility.ExitGUI();
        }

        HandleReorderDrop(headerRect, handleRect, indexInArray, groupTypeIndex);

        // --- Details ---
        if (foldoutStates[indexInArray])
        {
            EditorGUI.indentLevel++;

            if (typeProp != null)
                EditorGUILayout.PropertyField(typeProp, new GUIContent("Тип"));

            SerializedProperty loopProp = soundEntityProp.FindPropertyRelative("Loop");
            SerializedProperty volumeProp = soundEntityProp.FindPropertyRelative("Volume");

            if (loopProp != null)
                EditorGUILayout.PropertyField(loopProp);

            if (volumeProp != null)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.PropertyField(volumeProp);
                EditorGUILayout.LabelField($"{volumeProp.floatValue * 100:0}%", GUILayout.Width(50));
                EditorGUILayout.EndHorizontal();
            }

            EditorGUILayout.Space(5);
            EditorGUILayout.LabelField("Аудиоклипы", subHeaderStyle);

            if (clipsProp == null || !clipsProp.isArray)
            {
                EditorGUILayout.HelpBox("Поле Clips не найдено или не является массивом.", MessageType.Error);
            }
            else
            {
                if (GUILayout.Button("Добавить клип"))
                {
                    clipsProp.arraySize++;
                    serializedObject.ApplyModifiedProperties();
                }

                if (clipsProp.arraySize == 0)
                {
                    EditorGUILayout.HelpBox("Не добавлено ни одного аудиоклипа.", MessageType.Warning);
                }
                else
                {
                    for (int j = 0; j < clipsProp.arraySize; j++)
                    {
                        EditorGUILayout.BeginHorizontal();

                        SerializedProperty clipProp = clipsProp.GetArrayElementAtIndex(j);
                        EditorGUILayout.PropertyField(clipProp, new GUIContent($"Клип {j + 1}"));

                        GUI.enabled = clipProp.objectReferenceValue != null;
                        if (GUILayout.Button("▶", GUILayout.Width(25)))
                        {
                            AudioClip clip = clipProp.objectReferenceValue as AudioClip;
                            if (clip != null)
                            {
                                float volume = volumeProp != null ? volumeProp.floatValue : 1f;
                                AudioPreview.StopAllClips();
                                AudioPreview.PlayClip(clip, volume);
                            }
                        }

                        if (GUILayout.Button("■", GUILayout.Width(25)))
                        {
                            AudioPreview.StopAllClips();
                        }
                        GUI.enabled = true;

                        if (GUILayout.Button("×", GUILayout.Width(25)))
                        {
                            clipsProp.DeleteArrayElementAtIndex(j);
                            serializedObject.ApplyModifiedProperties();
                            break;
                        }

                        EditorGUILayout.EndHorizontal();
                    }
                }
            }

            EditorGUI.indentLevel--;
        }

        EditorGUILayout.EndVertical();
    }

    private void HandleReorderDrop(Rect headerRect, Rect handleRect, int targetIndexInArray, int groupTypeIndex)
    {
        Event e = Event.current;

        if (e.type == EventType.MouseDown && e.button == 0 && handleRect.Contains(e.mousePosition))
        {
            DragAndDrop.PrepareStartDrag();
            DragAndDrop.SetGenericData(DragKey, targetIndexInArray);
            DragAndDrop.objectReferences = Array.Empty<UnityEngine.Object>();
            e.Use();
        }
        else if (e.type == EventType.MouseDrag && e.button == 0)
        {
            if (DragAndDrop.GetGenericData(DragKey) != null)
            {
                DragAndDrop.StartDrag("Move Sound");
                e.Use();
            }
        }

        if ((e.type == EventType.DragUpdated || e.type == EventType.DragPerform) && headerRect.Contains(e.mousePosition))
        {
            object data = DragAndDrop.GetGenericData(DragKey);
            if (data is int sourceIndex)
            {
                if (sourceIndex < 0 || sourceIndex >= soundsEntitiesProp.arraySize) return;

                if (groupTypeIndex >= 0)
                {
                    int srcType = GetElementTypeIndex(sourceIndex);
                    int dstType = GetElementTypeIndex(targetIndexInArray);
                    if (srcType != dstType)
                    {
                        DragAndDrop.visualMode = DragAndDropVisualMode.Rejected;
                        return;
                    }
                }

                DragAndDrop.visualMode = DragAndDropVisualMode.Move;

                if (e.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();

                    int correctedDest = targetIndexInArray;
                    if (sourceIndex < correctedDest) correctedDest--;

                    MoveSoundEntity(sourceIndex, correctedDest);

                    DragAndDrop.SetGenericData(DragKey, null);
                    e.Use();
                    GUIUtility.ExitGUI();
                }
            }
        }

        if (e.type == EventType.DragExited)
        {
            DragAndDrop.SetGenericData(DragKey, null);
        }
    }

    private void HandleTypeDrop(Rect dropRect, int targetTypeIndex)
    {
        Event e = Event.current;

        if ((e.type == EventType.DragUpdated || e.type == EventType.DragPerform) && dropRect.Contains(e.mousePosition))
        {
            object data = DragAndDrop.GetGenericData(DragKey);
            if (data is int sourceIndex)
            {
                if (sourceIndex < 0 || sourceIndex >= soundsEntitiesProp.arraySize) return;

                DragAndDrop.visualMode = DragAndDropVisualMode.Move;

                if (e.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();

                    var el = soundsEntitiesProp.GetArrayElementAtIndex(sourceIndex);
                    var typeProp = el.FindPropertyRelative("type");
                    if (typeProp != null && typeProp.propertyType == SerializedPropertyType.Enum)
                    {
                        typeProp.enumValueIndex = Mathf.Clamp(targetTypeIndex, 0, soundTypeCount - 1);

                        int destIndex = FindInsertIndexAtEndOfType(targetTypeIndex, excludeIndex: sourceIndex);
                        if (destIndex >= 0 && destIndex < soundsEntitiesProp.arraySize)
                        {
                            int insertAt = Mathf.Min(destIndex + 1, soundsEntitiesProp.arraySize - 1);
                            if (sourceIndex != insertAt)
                            {
                                int corrected = insertAt;
                                if (sourceIndex < corrected) corrected--;
                                MoveSoundEntity(sourceIndex, corrected);
                            }
                        }

                        serializedObject.ApplyModifiedProperties();
                    }

                    DragAndDrop.SetGenericData(DragKey, null);
                    e.Use();
                    GUIUtility.ExitGUI();
                }
            }
        }
    }

    private int FindInsertIndexAtEndOfType(int typeIndex, int excludeIndex)
    {
        int last = -1;
        for (int i = 0; i < soundsEntitiesProp.arraySize; i++)
        {
            if (i == excludeIndex) continue;
            if (GetElementTypeIndex(i) == typeIndex)
                last = i;
        }
        return last;
    }

    private int GetElementTypeIndex(int index)
    {
        if (index < 0 || index >= soundsEntitiesProp.arraySize) return -1;
        var el = soundsEntitiesProp.GetArrayElementAtIndex(index);
        var typeProp = el.FindPropertyRelative("type");
        if (typeProp == null || typeProp.propertyType != SerializedPropertyType.Enum) return -1;
        return typeProp.enumValueIndex;
    }

    private void MoveSoundEntity(int from, int to)
    {
        if (from == to) return;
        if (from < 0 || to < 0) return;
        if (from >= soundsEntitiesProp.arraySize || to >= soundsEntitiesProp.arraySize) return;

        soundsEntitiesProp.MoveArrayElement(from, to);

        EnsureFoldoutStatesSize();
        bool state = foldoutStates[from];

        if (from < to)
        {
            for (int i = from; i < to; i++)
                foldoutStates[i] = foldoutStates[i + 1];
            foldoutStates[to] = state;
        }
        else
        {
            for (int i = from; i > to; i--)
                foldoutStates[i] = foldoutStates[i - 1];
            foldoutStates[to] = state;
        }

        serializedObject.ApplyModifiedProperties();
    }

    private void AddNewSoundEntity(int? typeIndexOverride = null)
    {
        soundsEntitiesProp.arraySize++;
        serializedObject.ApplyModifiedProperties();
        serializedObject.Update();

        EnsureFoldoutStatesSize();

        int newIndex = soundsEntitiesProp.arraySize - 1;
        foldoutStates[newIndex] = true;

        if (typeIndexOverride.HasValue)
        {
            var el = soundsEntitiesProp.GetArrayElementAtIndex(newIndex);
            var typeProp = el.FindPropertyRelative("type");
            if (typeProp != null && typeProp.propertyType == SerializedPropertyType.Enum)
            {
                typeProp.enumValueIndex = Mathf.Clamp(typeIndexOverride.Value, 0, Math.Max(0, soundTypeCount - 1));
                serializedObject.ApplyModifiedProperties();
            }
        }
    }

    private void AddNewSoundEntity()
    {
        AddNewSoundEntity(typeIndexOverride: null);
    }

    private void DeleteSoundEntity(int index)
    {
        if (index < 0 || index >= soundsEntitiesProp.arraySize) return;

        soundsEntitiesProp.DeleteArrayElementAtIndex(index);
        serializedObject.ApplyModifiedProperties();

        EnsureFoldoutStatesSize();
    }

    private static string GetPropertyAsSearchableText(SerializedProperty prop)
    {
        if (prop == null) return string.Empty;

        switch (prop.propertyType)
        {
            case SerializedPropertyType.String:
                return prop.stringValue;
            case SerializedPropertyType.Enum:
                return prop.enumDisplayNames != null && prop.enumValueIndex >= 0 && prop.enumValueIndex < prop.enumDisplayNames.Length
                    ? prop.enumDisplayNames[prop.enumValueIndex]
                    : prop.enumValueIndex.ToString();
            case SerializedPropertyType.Integer:
                return prop.intValue.ToString();
            case SerializedPropertyType.ObjectReference:
                return prop.objectReferenceValue != null ? prop.objectReferenceValue.name : string.Empty;
            default:
                return prop.displayName;
        }
    }
}

// Вспомогательный класс для проигрывания аудио в редакторе
public static class AudioPreview
{
    private static AudioClip currentPlayingClip;
    private static AudioSource previewAudioSource;

    public static void PlayClip(AudioClip clip, float volume = 1.0f)
    {
        if (clip == null) return;

        StopAllClips();

        try
        {
            if (previewAudioSource == null)
            {
                GameObject tempGO = GameObject.Find("__AudioPreviewObject");
                if (tempGO == null)
                {
                    tempGO = new GameObject("__AudioPreviewObject");
                    tempGO.hideFlags = HideFlags.HideAndDontSave;
                }

                previewAudioSource = tempGO.GetComponent<AudioSource>();
                if (previewAudioSource == null)
                {
                    previewAudioSource = tempGO.AddComponent<AudioSource>();
                }
            }

            previewAudioSource.clip = clip;
            previewAudioSource.volume = volume;
            previewAudioSource.loop = false;
            previewAudioSource.Play();

            currentPlayingClip = clip;

            Debug.Log($"Воспроизводится клип: {clip.name} с громкостью {volume}");
        }
        catch (Exception e)
        {
            Debug.LogError($"Ошибка воспроизведения аудио: {e.Message}");
        }
    }

    public static void StopAllClips()
    {
        try
        {
            if (previewAudioSource != null && previewAudioSource.isPlaying)
            {
                previewAudioSource.Stop();

                if (currentPlayingClip != null)
                {
                    Debug.Log($"Остановлен клип: {currentPlayingClip.name}");
                }
            }

            currentPlayingClip = null;

            Assembly unityEditorAssembly = typeof(AudioImporter).Assembly;
            Type audioUtilClass = unityEditorAssembly.GetType("UnityEditor.AudioUtil");
            MethodInfo method = audioUtilClass.GetMethod(
                "StopAllPreviewClips",
                BindingFlags.Static | BindingFlags.Public
            );

            method?.Invoke(null, null);
        }
        catch (Exception e)
        {
            Debug.LogError($"Ошибка остановки аудио: {e.Message}");
        }
    }

    public static bool IsPlaying()
    {
        return previewAudioSource != null && previewAudioSource.isPlaying;
    }

    [UnityEditor.InitializeOnLoadMethod]
    private static void Initialize()
    {
        UnityEditor.EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
    }

    private static void OnPlayModeStateChanged(UnityEditor.PlayModeStateChange state)
    {
        if (state == UnityEditor.PlayModeStateChange.EnteredPlayMode ||
            state == UnityEditor.PlayModeStateChange.ExitingEditMode)
        {
            StopAllClips();

            if (previewAudioSource != null)
            {
                GameObject tempGO = previewAudioSource.gameObject;
                previewAudioSource = null;
                UnityEngine.Object.DestroyImmediate(tempGO);
            }
        }
    }
}


--------------------
File: /Code/DefaultSystems/AudioSystem/SoundId.cs
--------------------

public enum SoundId
{
    none = 0,

    //SFX
    SFX_LevelTransiton = 1,
    SFX_Typing = 2,
    SFX_PlayerDamaged = 3,
    SFX_PlayerShielded = 4,
    SFX_PlayerHealed = 5,
    SFX_DamageBlocked = 6,
    SFX_EnemyDamaged = 7,
    SFX_CardDraw = 8,
    SFX_CardGrab = 9,
    SFX_CardSwap = 10,
    

    //Music
    Music_Main = 101,

    Music_Menu = 102,
    Music_Boss = 103,
    Music_Bonfire = 104,

    //Ambient
    Ambient_Sewer = 201
}

--------------------
File: /Code/DefaultSystems/AudioSystem/SoundsDataContainer.cs
--------------------

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "SoundsPool", menuName = "Audio/SoundsPool")]
public class SoundsDataContainer : ScriptableObject
{
    public List<SoundEntity> soundsEntities;
}

[System.Serializable]
public class SoundEntity
{
    [SerializeField] private SoundId soundId;
    public SoundId SoundId => soundId;
    public List<AudioClip> Clips;

    [SerializeField] private AudioType type;
    public AudioType Type => type;

    public bool Loop = false;
    [Range(0f, 1f)] public float Volume = 1f;

    public AudioClip GetClip()
    {
        if (Clips.Count > 1)
        {
            return Clips[Random.Range(0, Clips.Count)];
        }

        return Clips[0];
    }
}


--------------------
File: /Code/DefaultSystems/AudioSystem/SoundsLibrary.cs
--------------------

using System.Collections.Generic;
using UnityEngine;

public class SoundsLibrary : MonoBehaviour
{
    [SerializeField] private SoundsDataContainer soundsDataContainer;

    private Dictionary<SoundId, SoundEntity> soundsMap;

    private void Awake()
    {
        Initialize();
    }

    public void Initialize()
    {
        if (soundsDataContainer == null)
        {
            Debug.LogError("Не установлен SoundsDataContainer. Проверьте найстроки");
            return;
        }

        soundsMap = new Dictionary<SoundId, SoundEntity>();

        foreach (var sound in soundsDataContainer.soundsEntities)
        {
            if (!soundsMap.ContainsKey(sound.SoundId))
            {
                soundsMap.Add(sound.SoundId, sound);
            }
            else
            {
                Debug.LogWarning($"Дублирующийся SoundId: {sound.SoundId}. Проверьте настройки SoundsPool.");
            }
        }
    }

    public SoundEntity GetSound(SoundId soundId)
    {
        if (soundsMap == null)
        {
            return null;
        }

        if (soundsMap.TryGetValue(soundId, out SoundEntity sound))
        {
            if (sound.Clips == null)
            {
                Debug.LogWarning($"Звук с идентификатором {soundId} не имеет клипов");
                return null;
            }
            sound.Clips.RemoveAll(c => c == null);

            if (sound.Clips.Count == 0)
            {
                Debug.LogWarning($"Звук с идентификатором {soundId} не имеет клипов");
                return null;
            }

            return sound;
        }
        Debug.LogWarning($"Звук с идентификатором {soundId} не найден в пуле звуков.");
        return null;
    }
}

--------------------
File: /Code/DefaultSystems/CMS/CMS.cs
--------------------

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public static class CMS
{
    private static bool isInit;
    private static readonly Dictionary<string, ContentDef> _byId = new();
    private static readonly List<ContentDef> _all = new();

    public static void Init()
    {
        if (isInit) return;
        isInit = true;

        AutoAdd();
    }

    private static void AutoAdd()
    {
        _byId.Clear();
        _all.Clear();

        var allDefs = Resources.LoadAll<ContentDef>("Content");

        foreach (var def in allDefs)
        {
            if (def == null) continue;

            var id = def.Id;

            if (string.IsNullOrWhiteSpace(id))
            {
                Debug.LogWarning($"[CSM] Def '{def.name}' has empty Id");
                continue;
            }

            if (_byId.ContainsKey(id))
            {
                Debug.LogError($"[CSM] Duplicate Id '{id}' on asset '{def.name}' and '{_byId[id].name}'");
                continue;
            }

            _byId.Add(id, def);
            _all.Add(def);
        }

        Debug.Log($"[CSM] Loaded {_all.Count} defs");
    }

    // --- Публичное API ---

    public static ContentDef Get(string id)
    {
        Init();

        if (string.IsNullOrWhiteSpace(id))
        {
            Debug.LogError("[CSM] Get called with null/empty id");
            return null;
        }

        if (_byId.TryGetValue(id, out var def))
            return def;

        Debug.LogError($"[CSM] Def with Id '{id}' not found");
        return null;
    }

    public static T Get<T>(string id) where T : ContentDef
    {
        Init();

        if (!_byId.TryGetValue(id, out var def))
        {
            Debug.LogError($"[CSM] Def with Id '{id}' not found");
            return null;
        }

        if (def is T typed)
            return typed;

        Debug.LogError($"[CSM] Def '{id}' is '{def.GetType().Name}', not '{typeof(T).Name}'");
        return null;
    }

    /// <summary>Все дефы конкретного типа (например, все ItemDef).</summary>
    public static IEnumerable<T> GetAll<T>() where T : ContentDef
    {
        Init();
        return _all.OfType<T>();
    }

    /// <summary>Все ContentDef вообще.</summary>
    public static IEnumerable<ContentDef> GetAll()
    {
        Init();
        return _all;
    }
}

public static class CMSUtil
{
    public static T Load<T>(this string path) where T : Object
    {
        return Resources.Load<T>(path);
    }

    public static Sprite LoadFromSpritesheet(string imageName, string spriteName)
    {
        Sprite[] all = Resources.LoadAll<Sprite>(imageName);

        foreach (var s in all)
        {
            if (s.name == spriteName)
            {
                return s;
            }
        }

        return null;
    }
}

--------------------
File: /Code/DefaultSystems/CMS/ContentDef.cs
--------------------

using UnityEngine;

public abstract class ContentDef : ScriptableObject
{
    [Tooltip("Уникальный ID. Если пустой, будет использовано имя файла ассета.")]
    [SerializeField] private string id;

    public string Id => string.IsNullOrEmpty(id) ? name : id;
}

--------------------
File: /Code/DefaultSystems/CMS/Editor/ContentDefExplorerWindow.cs
--------------------

#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEngine;

/// <summary>
/// Простое окно-эксплорер для ContentDef:
/// - находит все ассеты ContentDef;
/// - группирует по типу (ItemDef, DiceDef, Card и т.п.);
/// - для CardModel внутри типа добавляет уровни по CardType (Start/Mid/End);
/// - поиск по имени / Id / типу / GUID / пути / папке;
/// - двойной клик пингует ассет в Project.
/// </summary>
public class ContentDefExplorerWindow : EditorWindow
{
    [Serializable]
    private class ContentDefInfo
    {
        public string Guid;
        public string AssetPath;
        public string FolderPath;      // относительный путь папки (Assets/./.)
        public string Name;            // имя ассета
        public string Id;              // ContentDef.Id
        public string TypeName;        // короткое имя типа (ItemDef, DiceDef и т.п.)
        public ContentDef Asset;       // ссылка на сам ассет
    }

    // --- TreeView ---

    // Используем новые дженериковые версии TreeViewItem / TreeView / TreeViewState с int в качестве идентификатора.
    private class ContentDefTreeItem : TreeViewItem<int>
    {
        public ContentDefInfo Info;

        public ContentDefTreeItem(int id, int depth, string displayName, ContentDefInfo info)
            : base(id, depth, displayName)
        {
            Info = info;
        }
    }

    private class ContentDefTreeView : TreeView<int>
    {
        private readonly List<ContentDefInfo> _allItems = new();
        private readonly Dictionary<int, ContentDefInfo> _idToInfo = new();
        private Action<ContentDefInfo> _onItemDoubleClick;

        public ContentDefTreeView(TreeViewState<int> state) : base(state)
        {
            showBorder = true;
            rowHeight = EditorGUIUtility.singleLineHeight + 2;
        }

        public void SetData(IEnumerable<ContentDefInfo> items, Action<ContentDefInfo> onItemDoubleClick)
        {
            _allItems.Clear();
            _allItems.AddRange(items);
            _onItemDoubleClick = onItemDoubleClick;
            Reload();
        }

        protected override TreeViewItem<int> BuildRoot()
        {
            // Корневой элемент (обязателен, id = 0, depth = -1)
            var root = new TreeViewItem<int>(0, -1, "Root");

            _idToInfo.Clear();

            if (_allItems.Count == 0)
            {
                // Пустой список
                root.AddChild(new TreeViewItem<int>(1, 0, "No ContentDef assets found"));
                return root;
            }

            // Группируем по типу ContentDef (ItemDef, DiceDef, DamageCard и т.п.)
            var groups = _allItems
                .GroupBy(i => i.TypeName)
                .OrderBy(g => g.Key, StringComparer.OrdinalIgnoreCase);

            int idCounter = 1;

            foreach (var group in groups)
            {
                var groupItem = new TreeViewItem<int>(idCounter++, 0, group.Key);
                root.AddChild(groupItem);

                // Проверяем: это группа карточек?
                bool isCardGroup = group.Any(i => i.Asset is CardModel);

                if (isCardGroup)
                {
                    // Внутри класса карт делаем доп.уровень по CardType (Start / Mid / End)
                    var byCardType = group
                        .GroupBy(info =>
                        {
                            if (info.Asset is CardModel card)
                                return card.CardType;
                            return CardType.None;
                        })
                        .OrderBy(g => g.Key); // порядок по enum CardType

                    foreach (var typeGroup in byCardType)
                    {
                        string headerName = typeGroup.Key.ToString(); // None / Start / Mid / End
                        var typeItem = new TreeViewItem<int>(idCounter++, 1, headerName);
                        groupItem.AddChild(typeItem);

                        foreach (var info in typeGroup.OrderBy(i => i.Name, StringComparer.OrdinalIgnoreCase))
                        {
                            var child = new ContentDefTreeItem(idCounter++, 2, info.Name, info);
                            typeItem.AddChild(child);
                            _idToInfo[child.id] = info;
                        }
                    }
                }
                else
                {
                    // Обычные типы как раньше: просто список ассетов
                    foreach (var info in group.OrderBy(i => i.Name, StringComparer.OrdinalIgnoreCase))
                    {
                        var child = new ContentDefTreeItem(idCounter++, 1, info.Name, info);
                        groupItem.AddChild(child);
                        _idToInfo[child.id] = info;
                    }
                }
            }

            // Обязательный вызов: сетим depth'ы и возвращаем
            SetupDepthsFromParentsAndChildren(root);
            return root;
        }

        protected override void RowGUI(RowGUIArgs args)
        {
            base.RowGUI(args);

            // Для листовых элементов (наши ContentDef) рисуем доп.инфу справа
            if (args.item is ContentDefTreeItem item && item.Info != null)
            {
                var rect = args.rowRect;
                rect.x += GetContentIndent(args.item) + 16f; // небольшой отступ от иконки/текста
                rect.width -= GetContentIndent(args.item) + 16f;

                // Лейаут: [Имя] | [Id] | [Папка]
                // Имя уже рисует базовый RowGUI, мы дорисуем Id и папку справа мелким текстом
                using (new EditorGUI.DisabledScope(true))
                {
                    var label = $"Id: {item.Info.Id}   •   Folder: {item.Info.FolderPath}";
                    var style = EditorStyles.miniLabel;
                    var size = style.CalcSize(new GUIContent(label));

                    var rightRect = new Rect(
                        rect.xMax - size.x - 8f,
                        rect.y + (rect.height - size.y) * 0.5f,
                        size.x + 8f,
                        size.y);

                    GUI.Label(rightRect, label, style);
                }
            }
        }

        protected override void DoubleClickedItem(int id)
        {
            if (_idToInfo.TryGetValue(id, out var info) && info.Asset != null)
            {
                _onItemDoubleClick?.Invoke(info);
            }
        }
    }

    // --- поля окна ---

    private TreeViewState<int> _treeViewState;
    private ContentDefTreeView _treeView;
    private SearchField _searchField;
    private string _searchText = string.Empty;
    private List<ContentDefInfo> _allDefs = new();
    private Vector2 _statusScroll;

    // --- меню ---

    [MenuItem("Tools/Content/ContentDef Explorer")]
    public static void Open()
    {
        var window = GetWindow<ContentDefExplorerWindow>("ContentDef Explorer");
        window.Show();
    }

    private void OnEnable()
    {
        if (_treeViewState == null)
            _treeViewState = new TreeViewState<int>();

        _treeView ??= new ContentDefTreeView(_treeViewState);
        _searchField ??= new SearchField();

        RefreshData();
    }

    private void OnGUI()
    {
        DrawToolbar();

        var rect = GUILayoutUtility.GetRect(0, 100000, 0, 100000);
        _treeView.OnGUI(rect);

        DrawStatusBar();
    }

    private void DrawToolbar()
    {
        using (new EditorGUILayout.HorizontalScope(EditorStyles.toolbar))
        {
            // Кнопка обновления
            if (GUILayout.Button("Refresh", EditorStyles.toolbarButton, GUILayout.Width(70)))
            {
                RefreshData();
            }

            GUILayout.Space(8);

            // Поиск
            GUILayout.Label("Search:", EditorStyles.toolbarButton, GUILayout.Width(50));
            var newSearch = _searchField.OnToolbarGUI(_searchText);
            if (newSearch != _searchText)
            {
                _searchText = newSearch;
                ApplyFilter();
            }

            GUILayout.FlexibleSpace();

            // Инфа по количеству
            GUILayout.Label($"Total: {_allDefs.Count}", EditorStyles.miniLabel);
        }
    }

    private void DrawStatusBar()
    {
        using (new EditorGUILayout.HorizontalScope(EditorStyles.helpBox))
        {
            _statusScroll = EditorGUILayout.BeginScrollView(
                _statusScroll,
                GUILayout.Height(EditorGUIUtility.singleLineHeight * 2)
            );

            if (_allDefs.Count == 0)
            {
                EditorGUILayout.LabelField("No ContentDef assets found in the project.", EditorStyles.miniLabel);
            }
            else
            {
                EditorGUILayout.LabelField(
                    "Hint: double-click a definition to ping it in the Project window.",
                    EditorStyles.miniLabel
                );
                EditorGUILayout.LabelField(
                    "Search works by Name, Id, Type name, GUID, path and folder.",
                    EditorStyles.miniLabel
                );
            }

            EditorGUILayout.EndScrollView();
        }
    }

    // --- логика загрузки и фильтрации ---

    private void RefreshData()
    {
        _allDefs.Clear();

        // Ищем ВСЕ ContentDef в проекте
        var guids = AssetDatabase.FindAssets("t:ContentDef");

        foreach (var guid in guids)
        {
            var path = AssetDatabase.GUIDToAssetPath(guid);
            var asset = AssetDatabase.LoadAssetAtPath<ContentDef>(path);
            if (asset == null)
                continue;

            var folder = Path.GetDirectoryName(path)?.Replace("\\", "/") ?? string.Empty;
            var type = asset.GetType();
            var info = new ContentDefInfo
            {
                Guid = guid,
                AssetPath = path,
                FolderPath = folder,
                Name = asset.name,
                Id = asset.Id,
                TypeName = type.Name,
                Asset = asset
            };

            _allDefs.Add(info);
        }

        ApplyFilter();
    }

    private void ApplyFilter()
    {
        IEnumerable<ContentDefInfo> result = _allDefs;

        if (!string.IsNullOrWhiteSpace(_searchText))
        {
            var search = _searchText.Trim();

            result = result.Where(i =>
                (!string.IsNullOrEmpty(i.Name) &&
                 i.Name.IndexOf(search, StringComparison.OrdinalIgnoreCase) >= 0) ||
                (!string.IsNullOrEmpty(i.Id) &&
                 i.Id.IndexOf(search, StringComparison.OrdinalIgnoreCase) >= 0) ||
                (!string.IsNullOrEmpty(i.TypeName) &&
                 i.TypeName.IndexOf(search, StringComparison.OrdinalIgnoreCase) >= 0) ||
                (!string.IsNullOrEmpty(i.Guid) &&
                 i.Guid.IndexOf(search, StringComparison.OrdinalIgnoreCase) >= 0) ||
                (!string.IsNullOrEmpty(i.AssetPath) &&
                 i.AssetPath.IndexOf(search, StringComparison.OrdinalIgnoreCase) >= 0) ||
                (!string.IsNullOrEmpty(i.FolderPath) &&
                 i.FolderPath.IndexOf(search, StringComparison.OrdinalIgnoreCase) >= 0)
            );
        }

        _treeView.SetData(result, OnItemDoubleClicked);
    }

    private void OnItemDoubleClicked(ContentDefInfo info)
    {
        if (info.Asset != null)
        {
            EditorGUIUtility.PingObject(info.Asset);
            Selection.activeObject = info.Asset;
        }
    }
}
#endif


--------------------
File: /Code/DefaultSystems/GameUtils.cs
--------------------

using System;
using System.Collections.Generic;
using System.Linq;

public static class GameUtils
{
    /// <summary>
    /// Returns a random element from the collection.
    /// Throws if the collection is null or empty.
    /// </summary>
    public static T GetRandomElement<T>(this IEnumerable<T> collection)
    {
        if (collection == null)
            throw new ArgumentNullException(nameof(collection));

        // Use indexable collections directly (arrays, lists, etc.)
        if (collection is IList<T> list && list.Count > 0)
        {
            int index = UnityEngine.Random.Range(0, list.Count);
            return list[index];
        }

        // Fallback for other IEnumerable<T> (HashSet, LINQ, etc.)
        var tempList = collection.ToList();
        if (tempList.Count == 0)
            throw new InvalidOperationException("Collection is empty.");

        int randomIndex = UnityEngine.Random.Range(0, tempList.Count);
        return tempList[randomIndex];
    }

    /// <summary>
    /// Shuffles the list in place using Fisher-Yates algorithm.
    /// </summary>
    public static IList<T> Shuffle<T>(this IList<T> list)
    {
        if (list == null)
            throw new ArgumentNullException(nameof(list));

        for (int i = 0; i < list.Count; i++)
        {
            int j = UnityEngine.Random.Range(i, list.Count);
            (list[i], list[j]) = (list[j], list[i]);
        }

        return list;
    }

    /// <summary>
    /// Returns a new shuffled list from the collection.
    /// The original collection is not modified.
    /// </summary>
    public static List<T> GetShuffled<T>(IEnumerable<T> collection)
    {
        if (collection == null)
            throw new ArgumentNullException(nameof(collection));

        var list = collection.ToList();
        Shuffle(list);
        return list;
    }
}

--------------------
File: /Code/DefaultSystems/SaveSystem/IDataService.cs
--------------------

public interface IDataService
{
    bool SaveData<T>(string RelativePath, T Data, bool Encrypted);

    T LoadData<T>(string RelativePath, bool Encrypted);
}


--------------------
File: /Code/DefaultSystems/SaveSystem/JSONDataService.cs
--------------------

using Newtonsoft.Json;
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;

public class JsonDataService : IDataService
{
    private const string KEY = "ggdPhkeOoiv6YMiPWa34kIuOdDUL7NwQFg6l1DVdwN8=";
    private const string IV = "JZuM0HQsWSBVpRHTeRZMYQ==";

    public bool SaveData<T>(string RelativePath, T Data, bool Encrypted)
    {
        string path = Application.persistentDataPath + RelativePath;

        try
        {
            if (File.Exists(path))
            {
                Debug.Log("Data exists. Deleting old file and writing a new one!");
                File.Delete(path);
            }
            else
            {
                Debug.Log("Writing file for the first time!");
            }
            using FileStream stream = File.Create(path);
            if (Encrypted)
            {
                WriteEncryptedData(Data, stream);
            }
            else
            {
                stream.Close();
                File.WriteAllText(path, JsonConvert.SerializeObject(Data));
            }
            return true;
        }
        catch (Exception e)
        {
            Debug.LogError($"Unable to save data due to: {e.Message} {e.StackTrace}");
            return false;
        }
    }

    private void WriteEncryptedData<T>(T Data, FileStream Stream)
    {
        using Aes aesProvider = Aes.Create();
        aesProvider.Key = Convert.FromBase64String(KEY);
        aesProvider.IV = Convert.FromBase64String(IV);
        using ICryptoTransform cryptoTransform = aesProvider.CreateEncryptor();
        using CryptoStream cryptoStream = new CryptoStream(
            Stream,
            cryptoTransform,
            CryptoStreamMode.Write
        );

        // You can uncomment the below to see a generated value for the IV & key.
        // You can also generate your own if you wish
        //Debug.Log($"Initialization Vector: {Convert.ToBase64String(aesProvider.IV)}");
        //Debug.Log($"Key: {Convert.ToBase64String(aesProvider.Key)}");
        cryptoStream.Write(Encoding.ASCII.GetBytes(JsonConvert.SerializeObject(Data)));
    }


    public T LoadData<T>(string RelativePath, bool Encrypted)
    {
        string path = Application.persistentDataPath + RelativePath;

        if (!File.Exists(path))
        {
            Debug.LogError($"Cannot load file at {path}. File does not exist!");
            throw new FileNotFoundException($"{path} does not exist!");
        }

        try
        {
            T data;
            if (Encrypted)
            {
                data = ReadEncryptedData<T>(path);
            }
            else
            {
                data = JsonConvert.DeserializeObject<T>(File.ReadAllText(path));
            }
            return data;
        }
        catch (Exception e)
        {
            Debug.LogError($"Failed to load data due to: {e.Message} {e.StackTrace}");
            throw e;
        }
    }

    private T ReadEncryptedData<T>(string Path)
    {
        byte[] fileBytes = File.ReadAllBytes(Path);
        using Aes aesProvider = Aes.Create();

        aesProvider.Key = Convert.FromBase64String(KEY);
        aesProvider.IV = Convert.FromBase64String(IV);

        using ICryptoTransform cryptoTransform = aesProvider.CreateDecryptor(
            aesProvider.Key,
            aesProvider.IV
        );
        using MemoryStream decryptionStream = new MemoryStream(fileBytes);
        using CryptoStream cryptoStream = new CryptoStream(
            decryptionStream,
            cryptoTransform,
            CryptoStreamMode.Read
        );
        using StreamReader reader = new StreamReader(cryptoStream);

        string result = reader.ReadToEnd();

        Debug.Log($"Decrypted result (if the following is not legible, probably wrong key or iv): {result}");
        return JsonConvert.DeserializeObject<T>(result);
    }
}


--------------------
File: /Code/DefaultSystems/SettingsUI/PauseManager.cs
--------------------

using UnityEngine;
using UnityEngine.UI;

public class PauseManager : MonoBehaviour
{
    [SerializeField] private Slider slider_SFX;
    [SerializeField] private Slider slider_Music;
    [SerializeField] private GameObject pausePanel;
    public bool IsOpen { get; private set; } = false;

    private void Start()
    {
        if (G.audioSystem == null) return;
        Init();
    }

    private void Init()
    {
        slider_Music.value = G.audioSystem.MusicVolume;
        slider_SFX.value = G.audioSystem.SfxVolume;
        SetToggle(false);
    }

    public void SetMusicVolume(float volume)
    {
        if (G.audioSystem == null) return;
        G.audioSystem.SetMusicVolume(volume);
        G.audioSystem.SetAmbientVolume(volume);
    }

    public void SetSFXVolume(float volume)
    {
        if (G.audioSystem == null) return;
        G.audioSystem.SetSFXVolume(volume);
    }

    public void SetToggle(bool toggle)
    {
        IsOpen = toggle;
        pausePanel.SetActive(IsOpen);
        //if (IsOpen)
        //{
        //    Time.timeScale = 0f;
        //}
        //else
        //{
        //    Time.timeScale = 1f;
        //}
    }

    public void Toggle()
    {
        bool b = !IsOpen;
        SetToggle(b);
    }
}

--------------------
File: /Code/Enemies/ActionDef.cs
--------------------

using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;


public enum InteractionType
{
    None = 0,
    Attack = 1,
    Shield = 2,
    Heal = 3
}


[Serializable]
public class ActionDef : ITooltipInfo
{
    public virtual InteractionType Type => GetActionType();
    [SerializeReference, SubclassSelector] public List<IOnEnemyTurnEnd> OnEndTurnInteractions;
    [HideInInspector] public int Amount;

    private InteractionType GetActionType()
    {
        foreach (var interaction in OnEndTurnInteractions)
        {
            if (interaction.type == InteractionType.None) continue;
            if (interaction is IAmountInteraction amountInteraction)
            {
                Amount = amountInteraction.GetAmount();
            }

            return interaction.type;
        }

        return InteractionType.None;
    }

    public string GetDescription()
    {
        if (OnEndTurnInteractions == null || OnEndTurnInteractions.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        for (int i = 0; i < OnEndTurnInteractions.Count; i++)
        {
            var interaction = OnEndTurnInteractions[i];
            if (interaction == null)
                continue;

            if (sb.Length > 0)
                sb.Append('\n');

            sb.Append(interaction.desc);
        }

        return sb.ToString();
    }

    public static Sprite GetSprite(InteractionType type)
    {
        switch (type)
        {
            case InteractionType.None:
                break;
            case InteractionType.Attack:
                return "Sprites/Actions/Attack".Load<Sprite>();
            case InteractionType.Shield:
                return "Sprites/Actions/Shield".Load<Sprite>();
            case InteractionType.Heal:
                return "Sprites/Actions/Heal".Load<Sprite>();
            default:
                throw new ArgumentOutOfRangeException(nameof(type), type, null);
        }

        return null;
    }

    public string ItemName => string.Empty;
    public string Description => GetDescription();
}

--------------------
File: /Code/Enemies/ActionTooltipGiver.cs
--------------------

using UnityEngine;

public class ActionTooltipGiver : MonoBehaviour, ITooltipInfoGiver
{
    [SerializeField] private EnemyInstance enemy;

    private void OnValidate()
    {
        if (enemy == null) enemy.GetComponentInParent<EnemyInstance>();
    }

    public ITooltipInfo GetTooltipInfo()
    {
        return enemy.nextAction;
    }
}

--------------------
File: /Code/Enemies/EnemyInstance.cs
--------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using TMPro;
using Unity.IntegerTime;
using UnityEngine;
using UnityEngine.Animations;
using UnityEngine.EventSystems;

public class EnemyInstance : MonoBehaviour, ITurnEntity, ICombatEntity, IPointerClickHandler
{
    public EnemyModel model;
    public int Speed { get; private set; }
    public int MaxHP { get; private set; }
    public int TurnOrder { get; private set; }
    public int CurrHP { get; private set; }
    public bool IsDead { get; private set; }
    public int CurrShield { get; private set; }
    public bool IsPossibleTarget { get; private set; }
    public int CurrTurnIndex = -1;


    public List<IStatusEffectInteraction> statusEffects { get; set; } = new();

    public ActionDef nextAction;
    public CombatGroup combatGroup;

    [Header("Visual References")] [SerializeField]
    private TMP_Text hpValueText;

    [SerializeField] private SpriteRenderer highlight;
    [SerializeField] private SpriteRenderer sprite;
    [SerializeField] private TMP_Text turnIndexText;
    [SerializeField] private SpriteRenderer actionIconImage;
    [SerializeField] private TMP_Text actionValueText;

    [SerializeField] private SpriteRenderer statusEffectsIcons;
    [SerializeField] private TMP_Text statusEffectsText;


    private void Start()
    {
        UpdateVisuals();
    }

    public void SetTarget(bool b)
    {
        IsPossibleTarget = b;
    }

    public void SetModel(EnemyModel newModel)
    {
        MaxHP = newModel.StartingHealth;
        model = newModel;
        if (model == null) return;
        Speed = model.Speed;
        CurrHP = model.StartingHealth;
        UpdateVisuals();
    }

    private void UpdateVisuals()
    {
        UpdateHpText();
        UpdateSprite();
        UpdateNextActionIcon();
        UpdateStatusIcon();
    }


    private void UpdateNextActionIcon()
    {
        actionIconImage.enabled = false;
        actionValueText.SetText("");

        nextAction = GetAction(CurrTurnIndex + 1, model.EndTurnActions);
        if (nextAction == null || nextAction.Type == InteractionType.None) return;

        var actionSprite = ActionDef.GetSprite(nextAction.Type);
        if (sprite == null) return;

        actionIconImage.enabled = true;
        actionIconImage.sprite = actionSprite;

        if (nextAction.Amount != 0)
        {
            actionValueText.SetText(nextAction.Amount.ToString());
        }
    }

    public int StatusTypeStacks(StatusEffectType type)
    {
        var stacks = 0;
        foreach (var statusEffectInteraction in statusEffects)
        {
            if (statusEffectInteraction.Type == type)
            {
                stacks += statusEffectInteraction.Stacks;
            }
        }

        return stacks;
    }

    private void UpdateStatusIcon()
    {
        statusEffectsIcons.enabled = false;
        statusEffectsText.SetText("");

        var effect = statusEffects.FirstOrDefault();
        if (effect == null || effect.Type == StatusEffectType.None) return;

        var sprite = effect.GetSprite();
        if (sprite == null) return;

        statusEffectsIcons.enabled = true;
        statusEffectsIcons.sprite = sprite;

        if (effect.Stacks != 0)
        {
            statusEffectsText.SetText(effect.Stacks.ToString());
        }
    }

    private void UpdateSprite()
    {
        if (sprite == null) return;
        sprite.sprite = model.Sprite;
    }

    private void UpdateHpText()
    {
        hpValueText.SetText("");
        if (model == null) return;

        hpValueText.SetText(CurrHP.ToString() + " / " + model.StartingHealth.ToString());
    }


    public void TakeDamage(int dmgAmount)
    {
        if (IsDead) return;
        if (dmgAmount <= 0) return;

        foreach (var statusEffectInteraction in statusEffects)
        {
            if (statusEffectInteraction is ITakenDamageFilter dmgFilter)
            {
                dmgAmount = dmgFilter.OnBeforeDamageTakenTick(dmgAmount);
            }
        }


        var remainDmg = dmgAmount;

        if (CurrShield > 0)
        {
            int absorbed = Mathf.Min(CurrShield, remainDmg);
            CurrShield -= absorbed;
            remainDmg -= absorbed;
        }

        if (remainDmg > 0)
        {
            CurrHP = Mathf.Max(0, CurrHP - remainDmg);
            G.audioSystem.Play(SoundId.SFX_EnemyDamaged);
        }
        else
        {
            G.audioSystem.Play(SoundId.SFX_DamageBlocked);
        }

        transform.DOPunchScale(new Vector3(0.2f, 0.2f, 0.2f), 0.2f);
        CheckIsDead();
        UpdateVisuals();
    }

    public void Heal(int amount)
    {
        if (IsDead) return;
        CurrHP = Mathf.Min(CurrHP + amount, MaxHP);
        UpdateVisuals();
    }

    public void AddShield(int amount)
    {
        if (IsDead) return;
        CurrShield += amount;
        UpdateVisuals();
    }

    public void SetShield(int amount)
    {
        if (IsDead) return;
        CurrShield = 0;
        AddShield(amount);
    }

    private void Update()
    {
        SetHighlight(IsPossibleTarget);
    }

    private void SetHighlight(bool b)
    {
        if (highlight == null) return;
        highlight.gameObject.SetActive(b);
    }


    private void CheckIsDead()
    {
        if (CurrHP <= 0)
        {
            IsDead = true;
            combatGroup.CheckMemberDeath(this);
            StopAllCoroutines();
            Destroy(gameObject);
        }
    }

    public void Kill()
    {
        TakeDamage(CurrHP);
    }


    public void AddStatus(IStatusEffectInteraction statusEffect, int stacks)
    {
        var existing = statusEffects.FirstOrDefault(s => s.GetType() == statusEffect.GetType());

        if (existing != null)
        {
            existing.AddStacks(stacks);
            Debug.Log($"Added stack {stacks} to {statusEffect.GetType()}");
        }
        else
        {
            var instance = (IStatusEffectInteraction)Activator.CreateInstance(statusEffect.GetType());
            instance.AddStacks(stacks);
            statusEffects.Add(instance);
        }

        UpdateStatusIcon();
    }

    public void SetTurnIndex(int index)
    {
        TurnOrder = index;
        UpdateTurnIndex();
    }

    public void UpdateTurnIndex()
    {
        turnIndexText.SetText("");
        if (TurnOrder > 0)
            turnIndexText.SetText(TurnOrder.ToString());
    }


    public void OnPointerClick(PointerEventData eventData)
    {
        G.main.TryChooseTarget(this);
    }

    public IEnumerator OnTurnEnd()
    {
        CurrTurnIndex++;


        foreach (var status in statusEffects)
        {
            if (status is IOnTurnEndStatusInteraction endStatus)
            {
                yield return endStatus.OnTurnEndTick(this);
                yield return new WaitForSeconds(0.2f);
                if (IsDead) yield break;
            }

            status.Tick();
        }

        statusEffects.RemoveAll(s => s.Stacks <= 0);
        UpdateStatusIcon();

        if (IsDead || !gameObject) yield break;

        var startPos = transform.position;
        var endPos = startPos;
        endPos.x -= 3f;
        transform.DOMove(endPos, 0.2f);
        yield return new WaitForSeconds(0.2f);

        var action = GetAction(CurrTurnIndex, model.EndTurnActions);

        if (action != null)
        {
            var inters = action.OnEndTurnInteractions;
            foreach (var inter in inters)
            {
                yield return inter.OnEndTurn(this);
            }
        }

        transform.DOMove(startPos, 0.2f);
        yield return new WaitForSeconds(0.2f);

        UpdateNextActionIcon();
    }

    public ActionDef GetAction(int turnIndex, List<ActionDef> actions)
    {
        var activeAct = actions.Where(r => r != null && r.OnEndTurnInteractions.Any()).ToList();

        if (activeAct.Count == 0)
        {
            Debug.LogWarning($"Enemy {model.name} has no actions defined.");
            return null;
        }

        int index = turnIndex % activeAct.Count;
        return actions[index];
    }
}

public interface ITurnEntity
{
    public int TurnOrder { get; }
    public int Speed { get; }
    public void SetTurnIndex(int turnIndex);
    public IEnumerator OnTurnEnd();
}

--------------------
File: /Code/Enemies/EnemyModel.cs
--------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;
using UnityEngine;


public interface IEnemyInteraction
{
    public InteractionType type { get; }
}

public interface IAmountInteraction
{
    int GetAmount();
}


[CreateAssetMenu(fileName = "EnemyModel", menuName = "Enemies/EnemyModel")]
public class EnemyModel : ContentDef, ITooltipInfo
{
    [Header("Enemy info")]
    [field: SerializeField]
    public string ItemName { get; private set; }

    [field: SerializeField] public string Description { get; private set; }
    [Header("Stats")] public int StartingHealth;
    public int preferPos;
    public int Speed;

    [Header("Enemy Visuals")] public Sprite Sprite;

    public EnemyInstance Prefab => "prefabs/Enemy".Load<EnemyInstance>();


    [SerializeField] public List<ActionDef> EndTurnActions = new List<ActionDef>();
}

public interface IOnEnemyTurnEnd : IEnemyInteraction
{
    public string desc { get; }
    public IEnumerator OnEndTurn(EnemyInstance e);
}


[Serializable]
public class DealDamageInteraction : IOnEnemyTurnEnd, IAmountInteraction
{
    public int[] possibleTargets;
    public int damageAmount;
    public string desc => "Will deal " + damageAmount + " damage";

    public IEnumerator OnEndTurn(EnemyInstance e)
    {
        var aliveTargets = possibleTargets.Where(i => G.party.CheckIsAlive(i)).ToArray();

        if (aliveTargets.Length == 0)
            yield break;

        var targetIndx = aliveTargets.GetRandomElement();
        G.party.DealDamage(targetIndx, damageAmount);
    }

    public InteractionType type => InteractionType.Attack;

    public int GetAmount()
    {
        return damageAmount;
    }
}

[Serializable]
public class DealDamageToRandomTarget : IOnEnemyTurnEnd, IAmountInteraction
{
    public int damageAmount;
    public string desc => "Will deal " + damageAmount + " dmg to random target";

    public IEnumerator OnEndTurn(EnemyInstance e)
    {
        var target = G.party.GetRandomMember();

        if (target == null || target.IsDead)
            yield break;


        target.TakeDamage(damageAmount);
    }

    public InteractionType type => InteractionType.Attack;

    public int GetAmount()
    {
        return damageAmount;
    }
}

[Serializable]
public class HealLowestTarget : IOnEnemyTurnEnd, IAmountInteraction
{
    public int HealAmount;
    public string desc => "Will heal allies ";

    public IEnumerator OnEndTurn(EnemyInstance e)
    {
        var target = G.enemies.GetLowestMember();

        if (target == null || target.IsDead)
            yield break;


        target.Heal(HealAmount);
    }

    public InteractionType type => InteractionType.Heal;

    public int GetAmount()
    {
        return HealAmount;
    }
}

[Serializable]
public class HealAllAllies : IOnEnemyTurnEnd, IAmountInteraction
{
    public int HealAmount;
    public string desc => "Will heal allies";

    public IEnumerator OnEndTurn(EnemyInstance e)
    {
        G.enemies.HealAll(HealAmount);
        yield return null;
    }

    public InteractionType type => InteractionType.Heal;

    public int GetAmount()
    {
        return HealAmount;
    }
}



--------------------
File: /Code/Enemies/IStatusEffectInteraction.cs
--------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IStatusEffectInteraction
{
    public abstract StatusEffectType Type { get; }
    public int Stacks { get; }
    public void AddStacks(int amount);
    public Sprite GetSprite();

    public void Tick();
}

public interface IOnTurnEndStatusInteraction : IStatusEffectInteraction
{
    IEnumerator OnTurnEndTick(ICombatEntity entity);
}


public interface ITakenDamageFilter : IStatusEffectInteraction
{
    int OnBeforeDamageTakenTick(int damage);
}

public interface ITargetFilter : IStatusEffectInteraction
{
    ICombatEntity OnTargetChoose(List<ICombatEntity> aliveMembers, ICombatEntity owner);
}


public enum StatusEffectType
{
    None = 0,
    Bleed = 1,
    Vulnerable = 2,
    Taunt = 3,
}


[Serializable]
public abstract class StatusEffectInteractionBase : IStatusEffectInteraction
{
    public abstract StatusEffectType Type { get; }
    public abstract string Description { get; }

    public int Stacks { get; protected set; } = 0;

    public void AddStacks(int amount)
    {
        Stacks += amount;
    }

    public virtual void Tick()
    {
        Stacks--;
    }


    public Sprite GetSprite()
    {
        switch (Type)
        {
            case StatusEffectType.None:
                break;
            case StatusEffectType.Bleed:
                return "Sprites/Effects/Bleed".Load<Sprite>();
            case StatusEffectType.Vulnerable:
                return "Sprites/Effects/Vuln".Load<Sprite>();
            case StatusEffectType.Taunt:
                return "Sprites/Effects/Taunt".Load<Sprite>();
            default:
                throw new ArgumentOutOfRangeException();
        }

        return null;
    }
}


[Serializable]
public class BleedStatusEffect : StatusEffectInteractionBase, IOnTurnEndStatusInteraction
{
    public override StatusEffectType Type => StatusEffectType.Bleed;
    public override string Description { get; }


    public IEnumerator OnTurnEndTick(ICombatEntity entity)
    {
        Debug.Log($"[Bleed] Tick on {entity} for {Stacks} dmg");
        entity.TakeDamage(Stacks);
        yield return null;
    }
}

[Serializable]
public class VulnerabilityStatusEffect : StatusEffectInteractionBase, ITakenDamageFilter
{
    private float multiplier = 1.25f;
    public override StatusEffectType Type => StatusEffectType.Vulnerable;

    public int OnBeforeDamageTakenTick(int damage)
    {
        return Mathf.RoundToInt(damage * 1.25f);
    }

    public override string Description { get; }
}

[Serializable]
public class TauntStatusEffect : StatusEffectInteractionBase, ITargetFilter
{
    public override StatusEffectType Type => StatusEffectType.Taunt;

    public ICombatEntity OnTargetChoose(List<ICombatEntity> aliveMembers, ICombatEntity statusOwner)
    {
        return statusOwner;
    }

    public override string Description { get; }
}

--------------------
File: /Code/Field/CardSlotView.cs
--------------------

using System;
using TMPro;
using UnityEngine;

public class CardSlotView : ContainerViewBase<DraggableCard, FieldCardSlot>
{
    [SerializeField] private TMP_Text slotTypeText;

    private void Start()
    {
        // UpdateText();
    }

    // private void UpdateText()
    // {
    //     slotTypeText.text = containerInst.acceptedType.ToShortName();
    // }
}





--------------------
File: /Code/Field/Field.cs
--------------------

using System.Linq;
using UnityEngine;

public class Field : MonoBehaviour
{
    public FieldCardSlot[] cardsSlots;

    public CardInstance[] PlayedCards => cardsSlots.Select(r => r.AcceptedCard).ToArray();

    private void OnValidate()
    {
        if (cardsSlots == null || cardsSlots.Length == 0 || cardsSlots.Length != transform.childCount)
            cardsSlots = GetComponentsInChildren<FieldCardSlot>();
    }

    public int CountCardsWithClass(ClassType classType)
    {
        var count = 0;
        foreach (var card in PlayedCards)
        {
            if (card == null) continue;
            if (card.state.model.ClassType == classType)
            {
                count++;
            }
        }

        return count;
    }


    public void Clear()
    {
        foreach (var c in cardsSlots)
        {
            if (c == null) continue;
            c.Clear();
        }
    }
}

--------------------
File: /Code/Field/FieldCardSlot.cs
--------------------

using System.Collections;
using TMPro;
using UnityEngine;

public class FieldCardSlot : ContainerBase<DraggableCard>, ITurnEntity
{
    public CardInstance AcceptedCard => GetAcceptedCard();

    [SerializeField] private TMP_Text turnIndexText;


    private CardInstance GetAcceptedCard()
    {
        if (AcceptedDrag == null) return null;
        return AcceptedDrag.instance;
    }

    public int TurnOrder { get; private set; }
    [field: SerializeField] public int Speed { get; private set; }


    public IEnumerator OnTurnEnd()
    {
        if (AcceptedCard != null) yield return AcceptedCard.OnTurnEnd();
    }

    private void UpdateTurnIndex()
    {
        turnIndexText.text = "";
        if (TurnOrder > 0)
            turnIndexText.text = TurnOrder.ToString();
    }

    public void SetTurnIndex(int turnIndex)
    {
        TurnOrder = turnIndex;
        UpdateTurnIndex();
    }
}

--------------------
File: /Code/Field/Hand.cs
--------------------

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class Hand : MonoBehaviour, IDraggableOwner<DraggableCard>
{
    public List<CardInstance> cardsInHand = new();
    [SerializeField] private Transform cardsParent;

    private const float PLACEMENT_X_RANGE = 1.75f;

    [Header("Hover layout")] [SerializeField]
    private float hoveredBottomY = -3f; // локальный Y для наведённой карты

    [SerializeField] private float hoverSpread = 0.6f;
    [SerializeField] private float hoverSpreadFar = 0.3f;
    [SerializeField] private float layoutLerpSpeed = 12f;


    private CardInstance _hoveredCard;

    public void SetHovered(CardInstance card)
    {
        if (card == null) return;
        _hoveredCard = card;
    }

    public void ClearHovered(CardInstance card)
    {
        // очищаем только если очищает именно текущий hover
        if (_hoveredCard == card)
            _hoveredCard = null;
    }

    private void Awake()
    {
        G.Hand = this;
    }

    private void Update()
    {
        if (cardsInHand.Count > 0) UpdateCardsPositions();
    }

    // 1) Базовая раскладка веером
    private void GetBaseLayout(int index, out Vector3 pos, out Quaternion rot)
    {
        float t = (cardsInHand.Count == 1)
            ? 0.5f
            : (float)index / (cardsInHand.Count - 1);

        float xPos = Mathf.Lerp(-6f / 2f, 6f / 2f, t);
        float centerT = t - 0.5f;
        float yPos = 0.5f * (1f - Mathf.Abs(centerT) * 2f);
        float rotationZ = -15f * centerT * 2f;

        pos = new Vector3(xPos, yPos, 0f);
        rot = Quaternion.Euler(0f, 0f, rotationZ);
    }

    private void ApplyHoverOffset(int index, int hoveredIndex, ref Vector3 pos, ref Quaternion rot)
    {
        if (hoveredIndex == -1)
            return;

        int delta = index - hoveredIndex;

        // 1) раздвигаем соседей по X
        float extraX = 0f;

        if (delta == -1) extraX -= hoverSpread;
        else if (delta == 1) extraX += hoverSpread;
        else if (delta <= -2) extraX -= hoverSpreadFar;
        else if (delta >= 2) extraX += hoverSpreadFar;

        pos.x += extraX;

        // 2) если это наведённая карта — особая раскладка
        if (index == hoveredIndex)
        {
            // строго вертикально
            rot = Quaternion.identity;

            // по нижней линии (локальный Y руки)
            pos.y = hoveredBottomY;
        }
    }

    public void UpdateCardsPositions()
    {
        int hoveredIndex = -1;
        if (_hoveredCard != null)
        {
            hoveredIndex = cardsInHand.IndexOf(_hoveredCard);
        }

        for (int i = 0; i < cardsInHand.Count; i++)
        {
            var c = cardsInHand[i];
            if (c == null) continue;

            if (c.Draggable != null &&
                (c.Draggable.IsDragging || c.Draggable.IsReturning))
                continue;

            GetBaseLayout(i, out Vector3 targetPos, out Quaternion targetRot);

            ApplyHoverOffset(i, hoveredIndex, ref targetPos, ref targetRot);

            c.transform.localPosition = Vector3.Lerp(
                c.transform.localPosition,
                targetPos,
                layoutLerpSpeed * Time.deltaTime
            );

            c.transform.localRotation = Quaternion.Lerp(
                c.transform.localRotation,
                targetRot,
                layoutLerpSpeed * Time.deltaTime
            );
        }
    }

    public void Draw()
    {
        var allCards = CMS.GetAll<CardModel>();
        var cardModel = allCards.GetRandomElement();
        var cardInst = Instantiate(cardModel.Prefab, cardsParent, false);
        cardInst.SetModel(cardModel);
        cardInst.Draggable.SetOwner(this);
    }

    public void Clear()
    {
        for (int i = 0; i < cardsInHand.Count; i++)
        {
            var d = cardsInHand[i];
            if (d == null) continue;

            // G.PileManager.Discard(d.DiceDef);
            Destroy(d.gameObject);
            cardsInHand[i] = null;
        }

        cardsInHand.Clear();
    }

    public void DrawControlledHand(int handSize)
    {
        // Минимальные количества (можешь потом подправить)
        const int MIN_DAMAGE = 2;
        const int MIN_TANK = 1;
        const int MIN_HEAL = 1;

        // Берём все модели карт из CMS
        var allCards = CMS.GetAll<CardModel>().ToList();

        // Разбиваем по классам
        var damageCards = allCards
            .Where(c => c.ClassType == ClassType.Damage)
            .ToList();

        var tankCards = allCards
            .Where(c => c.ClassType == ClassType.Tank)
            .ToList();

        var healCards = allCards
            .Where(c => c.ClassType == ClassType.Heal)
            .ToList();

        // Сюда будем складывать выбранные модели
        var modelsToSpawn = new List<CardModel>();
        int remaining = handSize;

        // Локальная функция спавна по модели
        void SpawnCard(CardModel model)
        {
            if (model == null) return;

            var cardInst = Instantiate(model.Prefab, cardsParent, false);
            cardInst.SetModel(model);
            cardInst.Draggable.SetOwner(this);
        }

        // Локальная функция — добавить N рандомных карт из списка (с дубликатами)
        void AddRandomFrom(List<CardModel> source, int count)
        {
            if (source == null || source.Count == 0) return;

            for (int i = 0; i < count; i++)
            {
                var model = source.GetRandomElement(); // твой GameUtils.GetRandomElement
                modelsToSpawn.Add(model);
            }
        }

        // 1) Гарантированные уроновые
        if (damageCards.Count > 0 && remaining > 0)
        {
            int count = Mathf.Min(MIN_DAMAGE, remaining);
            AddRandomFrom(damageCards, count);
            remaining -= count;
        }

        // 2) Гарантированные щиты
        if (tankCards.Count > 0 && remaining > 0)
        {
            int count = Mathf.Min(MIN_TANK, remaining);
            AddRandomFrom(tankCards, count);
            remaining -= count;
        }

        // 3) Гарантированные хильные
        if (healCards.Count > 0 && remaining > 0)
        {
            int count = Mathf.Min(MIN_HEAL, remaining);
            AddRandomFrom(healCards, count);
            remaining -= count;
        }

        // 4) Остаток — чем угодно (как твой обычный Draw)
        while (remaining > 0 && allCards.Count > 0)
        {
            var model = allCards.GetRandomElement();
            modelsToSpawn.Add(model);
            remaining--;
        }

        // 5) Спавним всё, что выбрали
        foreach (var model in modelsToSpawn)
        {
            SpawnCard(model);
        }
    }

    public void OnDragEnter(DraggableCard d)
    {
        var card = d.instance;
        if (cardsInHand.Contains(card)) return;

        cardsInHand.Add(card);
        card.transform.SetParent(cardsParent, worldPositionStays: true);
    }


    public void OnDragExit(DraggableCard d)
    {
        StartCoroutine(DragExitSequence(d));
    }

    public IEnumerator DragExitSequence(DraggableCard d)
    {
        var card = d.instance;
        cardsInHand.Remove(card);
        yield return G.main.OnCardPlayed(card);
    }
}

--------------------
File: /Code/Service/G.cs
--------------------

using System.Collections.Generic;
using UnityEngine;

public static class G
{
    public static EnemyGroup enemies;
    public static PartyManager party;
    public static Draggable currentDrag;


    public static AudioSystem audioSystem;

    public static Main main;
    public static ServiceMain ServiceMain;


    public static HUD HUD;
    public static UI UI;

    public static GameFeel feel = new GameFeel();
    public static ScreenFader ScreenFader;
    public static TextPopupManager textPopup;
    public static Hand Hand { get; set; }
}


public static class TextStuff
{
    public static string green = "#65FF5D";
    public static string red = "#F84D47";
    public static string blue => "#0087FF";

    public static Color GetColor(string html)
    {
        if (string.IsNullOrEmpty(html))
            return Color.white;

        if (!html.StartsWith("#"))
            html = "#" + html;

        if (ColorUtility.TryParseHtmlString(html, out var color))
            return color;

        Debug.LogWarning($"[TextStuff] Не удалось распарсить цвет: {html}");
        return Color.magenta;
    }

    public static string ToShortName(this CardType type)
    {
        return type switch
        {
            CardType.Start => "S",
            CardType.Mid => "M",
            CardType.End => "E",
            _ => "?"
        };
    }
}

--------------------
File: /Code/Service/GameFeel.cs
--------------------

using DG.Tweening;
using UnityEngine;

public class GameFeel
{
    public void PunchScale(Transform target, float strength = 0.25f, float duration = 0.25f, int vibrato = 8, float elasticity = 0.6f)
    {
        if (target == null) return;
        target.DOKill();

        target.DOPunchScale(
            punch: Vector3.one * strength,
            duration: duration,
            vibrato: vibrato,
            elasticity: elasticity
        ).SetEase(Ease.OutQuad);
    }

    public void Shake(Transform target, float duration = 0.3f, float strength = 0.5f, int vibrato = 10)
    {
        if (target == null) return;
        target.DOShakePosition(duration, strength, vibrato, randomness: 90f);
    }

    public void EnemyHitPunchScale(Transform t)
    {
        t.DOPunchScale(Vector3.one * 0.15f, 0.15f, 5, 0.8f);
    }

    public void PlayerHitPunch(Transform t)
    {
        t.DOPunchScale(Vector3.one * 0.1f, 0.12f, 4, 0.9f);
        Camera.main.transform.DOShakePosition(0.12f, 0.5f, 40, 90, false, true);
    }
}

--------------------
File: /Code/Service/Main.cs
--------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.PlayerLoop;
using UnityEngine.SceneManagement;
using Random = System.Random;


public class RunState
{
}

public class Main : MonoBehaviour
{
    public int DrawSize = 6;
    public static event UnityAction OnGameReady;
    public static bool TitleShown;
    public bool ShowTitle;
    public Field field;

    public bool IsChoosingTarget;

    private void Awake()
    {
        G.main = this;
    }

    private void Start()
    {
        CMS.Init();
        Debug.Log("OnGameReady");
        OnGameReady?.Invoke();

        StartCoroutine(GameStartSequence());
        
    }

    private IEnumerator GameStartSequence()
    {
        if (ShowTitle && !TitleShown) yield return ShowTitleScreen();

#if !UNITY_EDITOR
       while (!ServiceMain.ServicesReady) yield return null;
#endif
        yield return LoadLvl();
        G.audioSystem.Play(SoundId.Ambient_Sewer);

        StartTurn();
    }

    private IEnumerator LoadLvl()
    {
        var characters = CMS.GetAll<MemberModel>();
        foreach (var character in characters)
        {
            G.party.AddMember(character);
        }

        var enemies = CMS.GetAll<EnemyModel>().ToList();
        for (int i = 0; i <= 2; i++)
        {
            var enemy = enemies.GetRandomElement();
            G.enemies.AddEnemy(enemy);
        }

        yield break;
    }

    

    public void StartTurn()
    {
        StartCoroutine(StartTurnSequence());
    }

    private IEnumerator StartTurnSequence()
    {
        turns = BuildTurnOrder();
        //
        // for (int i = 0; i < DrawSize; i++)
        // {
        //     G.Hand.Draw();
        // }

        G.Hand.DrawControlledHand(DrawSize);

        G.HUD.SetEndTurnInteractable(true);

        yield return null;
    }

    private List<ITurnEntity> BuildTurnOrder()
    {
        var result = new List<ITurnEntity>();
        result.AddRange(G.enemies.GetAliveEnemies());
        result.AddRange(field.cardsSlots.Where(c => c != null));

        result = result.OrderByDescending(e => e.Speed).ToList();

        for (int i = 0; i < result.Count; i++)
        {
            if (result[i] is MonoBehaviour mb && mb == null) continue;
            result[i].SetTurnIndex(i + 1);
        }


        return result;
    }

    public void EndTurn()
    {
        StartCoroutine(EndTurnSequence());
    }


    public List<ITurnEntity> turns;

    private IEnumerator EndTurnSequence()
    {
        G.HUD.SetEndTurnInteractable(false);


        foreach (var turn in turns)
        {
            if (turn is MonoBehaviour mb && mb == null) continue;
            yield return turn.OnTurnEnd();
            if (CheckForWin())
            {
                yield return WinSequence();
                yield break;
            }

            yield return new WaitForSeconds(0.25f);
        }

        yield return FieldClearSequence();
        yield return StartTurnSequence();
    }


    public bool CheckForWin()

    {
        return G.enemies.AllMembersDead();
    }


    public void GameLost()
    {
        StartCoroutine(LoseSequence());
    }

    public IEnumerator LoseSequence()
    {
        G.UI.SetLoseActive(true);

        yield return new WaitForSecondsRealtime(2f);
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }


    private IEnumerator WinSequence()
    {
        G.UI.SetWinActive(true);

        yield return new WaitForSecondsRealtime(2f);
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }

    public IEnumerator FieldClearSequence()
    {
        G.Hand.Clear();
        field.Clear();
        yield return null;
    }


    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.R))
        {
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }

        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            var party = G.party.GetAliveMembers();
            foreach (var member in party)
            {
                member.Kill();
            }
        }
    }


    public void PlayCard(CardInstance card)
    {
        StartCoroutine(OnCardPlayed(card));
    }

    public IEnumerator OnCardPlayed(CardInstance card)
    {
        yield return card.OnCardPlayed();
    }

    private IEnumerator ShowTitleScreen()
    {
        G.UI.ToggleTitle(true);
        // G.audioSystem.Play(SoundId.SFX_LevelTransiton);
        
        yield return new WaitForSeconds(2f);
        G.ScreenFader.FadeOutCustom(G.UI.TitleScreenImage, 2f);
        TitleShown = true;
        yield break;
    }


    public void TryChooseTarget(ICombatEntity target)
    {
        if (!IsChoosingTarget) return;
        if (target == null) return;

        if (possibleTargets.Contains(target)) Target = target;
    }

    public ICombatEntity Target;
    public List<ICombatEntity> possibleTargets;

    public IEnumerator ChooseTarget(TargetSide targetSide, int[] targetsPos)
    {
        IsChoosingTarget = true;
        Target = null;

        CheckTargets(targetSide, targetsPos);

        if (possibleTargets.Count > 0)
        {
            while (Target == null)
                yield return null;
        }

        IsChoosingTarget = false;
        G.party.UntargetAll();
        G.enemies.UntargetAll();
    }

    public void CheckTargets(TargetSide targetSide, int[] possiblePos)
    {
        if (!IsChoosingTarget) return;
        List<ICombatEntity> targets;
        switch (targetSide)
        {
            case TargetSide.Any:
                targets = G.party.GetAliveMembers();
                targets.AddRange(G.enemies.GetAliveMembers());
                break;
            case TargetSide.Allies:
                targets = G.party.GetMembers(possiblePos).ToList();
                break;
            case TargetSide.Enemies:
                targets = G.enemies.GetMembers(possiblePos).ToList();
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }

        foreach (var target in targets)
        {
            if (target == null) continue;
            target.SetTarget(true);
        }

        possibleTargets = targets;
    }


    public void QuitGame()
    {
        Application.Quit();
    }
}

internal class LevelModel : ScriptableObject
{
}

public class Pile : MonoBehaviour
{
}

--------------------
File: /Code/Service/ServiceMain.cs
--------------------

using System;
using UnityEngine;

public class ServiceMain : MonoBehaviour
{
    public static bool ServicesReady { get; private set; }
    
    private void Awake()
    {
        if (G.ServiceMain != null && G.ServiceMain != this)
        {
            Destroy(this.gameObject);
            return;
        }
        DontDestroyOnLoad(gameObject);

        G.ServiceMain = this;
        InitializeServices();
    }

    public async void InitializeServices()
    {
        try
        {
            await AnalyticsSystem.Init();
        }
        catch (System.Exception e)
        {
            Debug.LogError($"[Services] Init failed: {e}");
        }
        finally
        {
            ServicesReady = true;
        }
    }

}

--------------------
File: /Code/UI/HUD.cs
--------------------

using System.Collections;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class HUD : MonoBehaviour
{
    [SerializeField] public Tooltip tooltip;
    [SerializeField] private PauseManager pauseManager;
    [SerializeField] private TMP_Text sayText;

    [Header("Buttons")] [SerializeField] private Button EndTurnButton;


    //Runtime
    private Coroutine sayRoutine;

    private bool skipType;

    private void OnValidate()
    {
        if (pauseManager == null) pauseManager = FindAnyObjectByType<PauseManager>();
    }

    private void Awake()
    {
        G.HUD = this;
    }

    private void Start()
    {
        EndTurnButton.onClick.AddListener(G.main.EndTurn);
    }


    public void HideHUD(bool b)
    {
    }


    public void SetEndTurnInteractable(bool b)
    {
        EndTurnButton.interactable = b;
    }


    public Coroutine Say(string text, float charDelay = 0.02f)
    {
        if (sayRoutine != null)
            StopCoroutine(sayRoutine);

        sayRoutine = StartCoroutine(SayRoutine(text, charDelay));
        return sayRoutine;
    }

    private IEnumerator SayRoutine(string text, float charDelay)
    {
        sayText.gameObject.SetActive(true);
        sayText.text = "";
        skipType = false;

        int charIndex = 0;
        foreach (char c in text)
        {
            if (skipType)
            {
                sayText.text = text;
                break;
            }

            sayText.text += c;

            if (charIndex % 2 == 0)
            {
                G.audioSystem.Play(SoundId.SFX_Typing);
            }

            charIndex++;
            yield return new WaitForSeconds(charDelay);
        }

        yield return WaitForLeftClick();
        sayText.gameObject.SetActive(false);
    }

    private IEnumerator WaitForLeftClick()
    {
        yield return null;
        while (!Input.GetMouseButtonDown(0) && !Input.GetKeyDown(KeyCode.Space))
        {
            if (Input.GetMouseButton(0) || Input.GetKey(KeyCode.Space))
                skipType = true;
            yield return null;
        }
    }

    public void TogglePause(bool pause)
    {
        if (pauseManager == null) return;
        pauseManager.SetToggle(pause);
    }
}

--------------------
File: /Code/UI/ScreenFader.cs
--------------------

using DG.Tweening;
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class ScreenFader : MonoBehaviour
{
    [SerializeField] private Image fadeImage;
    [SerializeField] private float fadeTime = 0.5f;
    public float FadeTime => fadeTime;

    private Sequence currentSequence;

    private void OnValidate()
    {
        if (fadeImage == null) fadeImage = GetComponent<Image>();
        else if (fadeImage != null)
        {
            Color panelColor = Color.black;
            panelColor.a = 0f;
            fadeImage.color = panelColor;
        }
    }

    private void Awake()
    {
        if (G.ScreenFader != null && G.ScreenFader != this)
        {
            Destroy(gameObject);
            return;
        }
        DontDestroyOnLoad(this.gameObject);

        G.ScreenFader = this;
        fadeImage.gameObject.SetActive(false);
    }

    public void FadeIn(float time = 0f, Action onComplete = null)
    {
        if (time == 0) time = fadeTime;
        KillCurrentSequence();

        fadeImage.gameObject.SetActive(true);

        currentSequence = DOTween.Sequence();
        currentSequence.SetUpdate(true);

        Color startColor = fadeImage.color;
        startColor.a = 0f;
        fadeImage.color = startColor;
        currentSequence.Append(fadeImage.DOFade(1f, time).SetEase(Ease.InOutSine));

        if (onComplete != null)
        {
            currentSequence.OnComplete(() => onComplete.Invoke());
        }
    }

    public void FadeOut(float time = 0f, Action onComplete = null)
    {
        if (time == 0) time = fadeTime;
        KillCurrentSequence();

        fadeImage.gameObject.SetActive(true);

        currentSequence = DOTween.Sequence();
        currentSequence.SetUpdate(true);

        Color startColor = fadeImage.color;
        startColor.a = 1f;
        fadeImage.color = startColor;

        currentSequence.Append(fadeImage.DOFade(0f, time).SetEase(Ease.InOutSine));

        if (onComplete != null)
        {
            currentSequence.OnComplete(() =>
            {
                fadeImage.gameObject.SetActive(false);
                onComplete.Invoke();
            });
        }
        else
        {
            currentSequence.OnComplete(() =>
            {
                fadeImage.gameObject.SetActive(false);
            });
        }
    }

    public void FadeOutCustom(Image screen, float time = 0f, Action onComplete = null)
    {
        if (time == 0) time = fadeTime;
        KillCurrentSequence();

        screen.gameObject.SetActive(true);

        currentSequence = DOTween.Sequence();
        currentSequence.SetUpdate(true);

        Color startColor = screen.color;
        startColor.a = 1f;
        screen.color = startColor;

        currentSequence.Append(screen.DOFade(0f, time).SetEase(Ease.InOutSine));

        if (onComplete != null)
        {
            currentSequence.OnComplete(() =>
            {
                screen.gameObject.SetActive(false);
                onComplete.Invoke();
            });
        }
        else
        {
            currentSequence.OnComplete(() =>
            {
                screen.gameObject.SetActive(false);
            });
        }
    }

    public void TransitionFade(float time = 0f, Action action = null)
    {
        FadeIn(time, () =>
        {
            action?.Invoke();
            FadeOut();
        });
    }

    private void KillCurrentSequence()
    {
        if (currentSequence != null && currentSequence.IsActive())
        {
            currentSequence.Kill();
            currentSequence = null;
        }
    }

    public void StartLevelTransition()
    {
        if (currentSequence != null) return;
        StartCoroutine(LevelTransition());
    }

    public IEnumerator LevelTransition()
    {
        G.ScreenFader.FadeIn(1f);
        yield return new WaitForSeconds(0.5f);
        G.audioSystem.Play(SoundId.SFX_LevelTransiton);
        yield return new WaitForSeconds(1f);
        G.ScreenFader.FadeOut(1f);
    }
}

--------------------
File: /Code/UI/TextPopup.cs
--------------------

using UnityEngine;

public class TextPopupManager : MonoBehaviour
{
    public TextPopupInstance popupPrefab;

    private void Awake()
    {
        G.textPopup = this;
    }

    public void Spawn(Vector3 worldPos, int amount, bool isHeal = false)
    {
        if (!popupPrefab) { Debug.LogWarning("TextPopupManager: popupPrefab is null"); return; }
        var inst = Instantiate(popupPrefab, worldPos, Quaternion.identity);
        inst.Play(amount, isHeal);
    }

    public void SpawnAbove(Transform anchor, float offsetY, int amount, bool isHeal = false)
    {
        if (!anchor) return;
        Spawn(anchor.position + Vector3.up * offsetY, amount, isHeal);
    }
}

--------------------
File: /Code/UI/TextPopupInstance.cs
--------------------

using DG.Tweening;
using System;
using TMPro;
using UnityEngine;

public class TextPopupInstance : MonoBehaviour
{
    public TMP_Text label;

    [Header("Motion")]
    public float riseDistance = 1f;

    public float duration = 0.6f;

    public void Play(int amount, bool isHeal = false)
    {
        if (!label) label = GetComponentInChildren<TMP_Text>(true);
        amount = Math.Abs(amount);
        label.text = (isHeal ? "+" : "-") + amount;
        label.color = isHeal ? new Color(0.4f, 1f, 0.4f) : new Color(1f, 0.4f, 0.4f);
        label.alpha = 1f;

        var t = transform;
        t.localScale = Vector3.one * 0.9f;

        Sequence s = DOTween.Sequence();
        s.Append(t.DOMoveY(t.position.y + riseDistance, duration).SetEase(Ease.OutQuad));
        s.Join(t.DOScale(1.1f, duration));
        s.Join(label.DOFade(0f, duration).SetEase(Ease.InQuad).SetDelay(duration * 0.3f));
        s.OnComplete(() => Destroy(gameObject));
    }
}

--------------------
File: /Code/UI/Tooltip/ITooltipInfo.cs
--------------------

public interface ITooltipInfo
{
    string ItemName { get; }
    string Description { get; }
}

public interface ITooltipInfoGiver
{
    ITooltipInfo GetTooltipInfo();
}

--------------------
File: /Code/UI/Tooltip/Tooltip.cs
--------------------

using System;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class Tooltip : MonoBehaviour
{
    [Header("Tooltip settings")] [SerializeField]
    private TMP_Text nameText;

    private Camera _camera;
    [SerializeField] private TMP_Text descText;
    [SerializeField] private RectTransform Rect;
    [SerializeField] private Canvas canvas;
    [SerializeField] private LayoutElement layout;
    [SerializeField] private int minWidth = 70;
    public Vector2 offset;
    [SerializeField] private Vector2 offscreenOffset = new Vector2(10f, 10f);

    public bool IsBlocked => blockersCount > 0;
    private int blockersCount = 0;
    private GameObject currUser;

    public void PushBlock()
    {
        blockersCount++;
        Hide();
    }

    public void PopBlock()
    {
        blockersCount = Mathf.Max(0, blockersCount - 1);
    }

    private void Start()
    {
        Hide();
        _camera = Camera.main;
    }

    // public void Show(ITooltipInfo data, bool showAdditionalTooltip, GameObject user)
    // {
    //     Show(data, user);
    // }

    public void Show(ITooltipInfo data, GameObject user)
    {
        //Debug.Log("Showing tooltip for: " + data.ItemName);
        if (IsBlocked) return;
        if (data == null) return;
        this.currUser = user;
        if (string.IsNullOrEmpty(data.Description) && string.IsNullOrEmpty(data.ItemName)) return;

        nameText.text = data.ItemName;
        descText.text = data.Description;
        var textWidth = nameText.preferredWidth + 6;
        layout.preferredWidth = textWidth > minWidth ? textWidth : minWidth;

        UpdatePos();
        Rect.gameObject.SetActive(true);
    }

    public void Hide()
    {
        currUser = null;
        Rect.gameObject.SetActive(false);
    }

    private void Update()
    {
        if (!Rect.gameObject.activeSelf) return;
        if (!currUser || !currUser.activeInHierarchy)
        {
            Hide();
            return;
        }

        UpdatePos();
    }

    private void UpdatePos()
    {
        Vector2 mousePos = Input.mousePosition;

        RectTransform canvasRect = canvas.GetComponent<RectTransform>();
        RectTransformUtility.ScreenPointToLocalPointInRectangle(canvasRect, mousePos, _camera, out var localPoint);
        localPoint += offset;
        Rect.anchoredPosition = localPoint;
    }
}

--------------------
File: /Code/UI/Tooltip/TooltipInteractor.cs
--------------------

using UnityEngine;
using UnityEngine.EventSystems;

public class TooltipInteractor : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    [SerializeField] private ITooltipInfoGiver InfoGiver;
    private bool isCurrentlyHovered = false;

    private void Awake()
    {
        InfoGiver = GetComponent<ITooltipInfoGiver>();
        if (InfoGiver == null)
        {
            Debug.LogError("Can't find tooltip giver attached to object " + gameObject.name);
        }
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        //Debug.Log("Pointer entered: " + gameObject.name);
        if (eventData.pointerCurrentRaycast.gameObject != gameObject)
            return;

        isCurrentlyHovered = true;

        if (InfoGiver != null && G.HUD != null && G.HUD.tooltip != null)
        {
            G.HUD.tooltip.Show(InfoGiver.GetTooltipInfo(), gameObject);
        }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (!isCurrentlyHovered)
            return;

        isCurrentlyHovered = false;

        if (G.HUD != null && G.HUD.tooltip != null)
        {
            G.HUD.tooltip.Hide();
        }
    }
}


--------------------
File: /Code/UI/UI.cs
--------------------

using UnityEngine;
using UnityEngine.UI;

public class UI : MonoBehaviour
{
    [SerializeField] private GameObject winScreen;
    [SerializeField] private GameObject loseScreen;
    [SerializeField] private GameObject titleScreen;

    public Image TitleScreenImage => titleScreen.GetComponent<Image>();


    private void Awake()
    {
        G.UI = this;
    }

    private void Start()
    {
    }

    public void SetWinActive(bool win)
    {
        if (winScreen == null) return;
        winScreen.SetActive(win);
    }

    public void SetLoseActive(bool win)
    {
        if (loseScreen == null) return;
        loseScreen.SetActive(win);
    }

    public void ToggleTitle(bool b)
    {
        if (titleScreen == null) return;
        titleScreen.SetActive(b);
    }

    public void HideAllUI(bool hide)
    {
        if (winScreen != null) winScreen.SetActive(!hide);
        if (loseScreen != null) loseScreen.SetActive(!hide);
        if (titleScreen != null) titleScreen.SetActive(!hide);
    }
}

--------------------
File: /Code/VFX/CardHoverVfx.cs
--------------------

using UnityEngine;
using UnityEngine.EventSystems;
using DG.Tweening;
using UnityEngine.Rendering;

public class CardHoverVFX : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    [Header("Hand hover")] [SerializeField]
    private float handHoverScale = 1.7f;

    [Header("Slot hover")] [SerializeField]
    private float slotHoverScale = 1.5f;

    [SerializeField] private float slotHoverLift = 0.2f;
    [SerializeField] private float slotHoverTiltX = -10f;
    [SerializeField] private float slotHoverAnimDuration = 0.12f;

    [Header("Common")] [SerializeField] private float scaleDuration = 0.12f;
    [SerializeField] private Ease scaleEase = Ease.OutBack;
    [SerializeField] private Transform visual; // ССЫЛКА НА ВИЗУАЛ КАРТЫ

    [Header("Sorting / Front")] [SerializeField]
    private int hoverSortingBoost = 200;

    [SerializeField] private bool bringToFrontInUIIfNoSortingGroup = true;

    private CardInstance _card;
    private Draggable _draggable;
    private DraggableCard _draggableCard;

    private SortingGroup _sortingGroup;
    private int _baseSortingOrder;
    private Transform _baseParent;
    private int _baseSiblingIndex;

    private bool _isDragging;

    private Vector3 _baseScale;
    private Vector3 _visualBaseLocalPos;
    private Quaternion _visualBaseLocalRot;

    private Tween _scaleTween;
    private Tween _slotMoveTween;
    private Tween _slotRotateTween;


    private void Awake()
    {
        _card = GetComponent<CardInstance>() ?? GetComponentInParent<CardInstance>();
        _draggable = GetComponentInParent<Draggable>();
        _draggableCard = GetComponentInParent<DraggableCard>();

        if (_draggable != null)
        {
            _draggable.OnDragBegin += HandleDragBegin;
            _draggable.OnDragEnd += HandleDragEnd;
        }

        if (visual == null)
        {
            var t = transform.Find("Visual");
            visual = t != null ? t : transform;
        }

        _baseScale = visual.localScale;
        _visualBaseLocalPos = visual.localPosition;
        _visualBaseLocalRot = visual.localRotation;

        _sortingGroup = GetComponent<SortingGroup>();
        if (_sortingGroup != null)
            _baseSortingOrder = _sortingGroup.sortingOrder;

        _baseParent = transform.parent;
        _baseSiblingIndex = transform.GetSiblingIndex();
    }


    private bool IsInSlot()
    {
        return _draggableCard != null &&
               _draggableCard.CurrContainer != null;
    }


    private void HandleDragBegin()
    {
        _isDragging = true;
        
        _card?.Hand?.ClearHovered(_card);
        
        _scaleTween?.Kill();
        _slotMoveTween?.Kill();
        _slotRotateTween?.Kill();
        
        visual.localPosition = _visualBaseLocalPos;
        visual.localRotation = _visualBaseLocalRot;
        

    }


    private void HandleDragEnd()
    {
        _isDragging = false;
        
        _scaleTween?.Kill();
        _slotMoveTween?.Kill();
        _slotRotateTween?.Kill();
        visual.DOKill();
        
        visual.localScale = _baseScale;
        visual.localPosition = _visualBaseLocalPos;
        visual.localRotation = _visualBaseLocalRot;
        
        RestoreOrder();
    }


    public void OnPointerEnter(PointerEventData eventData)
    {
        if (Draggable.DisableHoverGlobal)
            return;
        
        if (G.currentDrag != null)
            return;
        
        
        if (Time.time < _draggable.HoverLockUntil) return;
        if (_isDragging) return;

        if (IsInSlot())
        {
            visual.DOKill();
            PlaySlotHoverScale(true);


            _slotMoveTween = visual.DOLocalMove(
                    _visualBaseLocalPos + new Vector3(0f, slotHoverLift, 0f),
                    slotHoverAnimDuration)
                .SetEase(Ease.OutCubic);

            _slotRotateTween = visual.DOLocalRotateQuaternion(
                    Quaternion.Euler(slotHoverTiltX, 0f, 0f) * _visualBaseLocalRot,
                    slotHoverAnimDuration)
                .SetEase(Ease.OutCubic);

            BringToFront();
            return;
        }
        
        PlayHandHoverScale(true);
        BringToFront();
        _card?.Hand?.SetHovered(_card);
    }


    public void OnPointerExit(PointerEventData eventData)
    {
        if (Draggable.DisableHoverGlobal)
            return;
        
        if (Time.time < _draggable.HoverLockUntil) return;
        if (_isDragging) return;

        if (IsInSlot())
        {
            if (G.currentDrag != null)
                return;
            
            visual.DOKill();
            PlaySlotHoverScale(false);

            _slotMoveTween = visual.DOLocalMove(_visualBaseLocalPos, slotHoverAnimDuration)
                .SetEase(Ease.OutCubic);
            _slotRotateTween = visual.DOLocalRotateQuaternion(_visualBaseLocalRot, slotHoverAnimDuration)
                .SetEase(Ease.OutCubic);

            RestoreOrder();
            return;
        }
        
        PlayHandHoverScale(false);
        RestoreOrder();
        _card?.Hand?.ClearHovered(_card);
    }


    private void PlayScale(Vector3 target)
    {
        _scaleTween?.Kill();
        _scaleTween = visual.DOScale(target, scaleDuration)
            .SetEase(scaleEase)
            .SetUpdate(true);
    }


    private void BringToFront()
    {
        if (_sortingGroup != null)
        {
            _sortingGroup.sortingOrder = _baseSortingOrder + hoverSortingBoost;
            return;
        }

        if (bringToFrontInUIIfNoSortingGroup && transform.parent != null)
        {
            transform.SetAsLastSibling();
        }
    }

    private void RestoreOrder()
    {
        if (_sortingGroup != null)
        {
            _sortingGroup.sortingOrder = _baseSortingOrder;
            return;
        }

        if (bringToFrontInUIIfNoSortingGroup && transform.parent == _baseParent)
        {
            transform.SetSiblingIndex(_baseSiblingIndex);
        }
    }

    private void OnDisable()
    {
        _scaleTween?.Kill();
        visual.localScale = _baseScale;
        RestoreOrder();
    }

    private void PlayHandHoverScale(bool hovered)
    {
        var target = hovered ? _baseScale * handHoverScale : _baseScale;

        _scaleTween?.Kill();
        _scaleTween = visual.DOScale(target, scaleDuration)
            .SetEase(scaleEase)
            .SetUpdate(true);
    }

    private void PlaySlotHoverScale(bool hovered)
    {
        var target = hovered ? _baseScale * slotHoverScale : _baseScale;

        _scaleTween?.Kill();
        _scaleTween = visual.DOScale(target, slotHoverAnimDuration)
            .SetEase(scaleEase)
            .SetUpdate(true);
    }
    
    public void ResetVisual()
    {
        _scaleTween?.Kill();
        _slotMoveTween?.Kill();
        _slotRotateTween?.Kill();

        visual.localScale = _baseScale;
        visual.localPosition = _visualBaseLocalPos;
        visual.localRotation = _visualBaseLocalRot;

        RestoreOrder();
    }
    

}

